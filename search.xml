<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring面试题</title>
      <link href="2021/06/04/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/06/04/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring框架"><a href="#什么是Spring框架" class="headerlink" title="什么是Spring框架"></a>什么是Spring框架</h2><p>spring是一个容器 ， 是spring是03年兴起的一个轻量级的java开放框架， 它是为了解决管理对象的复杂性而创建的， spring的两大核心和 IOC （控制反转）和 AOP （面向切面编程） 是可以在JavaSE和JavaEE中使用的轻量级开源框架。</p><h2 id="列举一些重要的Spring模块"><a href="#列举一些重要的Spring模块" class="headerlink" title="列举一些重要的Spring模块"></a>列举一些重要的Spring模块</h2><ul><li>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IOC 依赖注入功能。</li><li>**Spring Aspects ** ： 该模块为与AspectJ的集成提供支持。</li><li>Spring AOP ：提供了面向方面的编程实现。</li><li>Spring JDBC : Java数据库连接。</li><li>Spring JMS ：Java消息服务。</li><li>Spring ORM : 用于支持Hibernate等ORM工具。</li><li>Spring Web : 为创建Web应用程序提供支持。</li><li>Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。</li></ul><h2 id="谈谈自己对于-Spring-IOC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IOC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IOC 和 AOP 的理解"></a>谈谈自己对于 Spring IOC 和 AOP 的理解</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP（Aspect-Oriented Programming:面向切面编程）能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别"></a>Spring AOP 和 AspectJ AOP 有什么区别</h2><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些"></a>Spring 中的 bean 的作用域有哪些</h2><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><h2 id="Spring-中的单例-bean-的线程安全问题"><a href="#Spring-中的单例-bean-的线程安全问题" class="headerlink" title="Spring 中的单例 bean 的线程安全问题"></a>Spring 中的单例 bean 的线程安全问题</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><p>常见的有两种解决办法：</p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><h2 id="Spring-中的-bean-的生命周期"><a href="#Spring-中的-bean-的生命周期" class="headerlink" title="Spring 中的 bean 的生命周期"></a>Spring 中的 bean 的生命周期</h2><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用 set()方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。</li><li>如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。</li><li>与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法</li><li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="/2021/06/04/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/1.png"></p><h2 id="Spring-MVC-理解"><a href="#Spring-MVC-理解" class="headerlink" title="Spring MVC 理解"></a>Spring MVC 理解</h2><p>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。</p><p> Spring的MVC框架主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p><p>Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</p><h2 id="Spring-框架中用到了哪些设计模式"><a href="#Spring-框架中用到了哪些设计模式" class="headerlink" title="Spring 框架中用到了哪些设计模式"></a>Spring 框架中用到了哪些设计模式</h2><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li></ul><h2 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h2><ol><li>作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。</li><li>@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li></ol><h2 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些"></a>将一个类声明为Spring的 bean 的注解有哪些</h2><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于拿个层，可以使</li><li>@Component 注解标注。</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="Spring-管理事务的方式有几种"><a href="#Spring-管理事务的方式有几种" class="headerlink" title="Spring 管理事务的方式有几种"></a>Spring 管理事务的方式有几种</h2><ol><li>编程式事务，在代码中硬编码。(不推荐使用)</li><li>声明式事务，在配置文件中配置（推荐使用）</li></ol><p><strong>声明式事务又分为两种：</strong></p><ol><li>基于XML的声明式事务</li><li>基于注解的声明式事务</li></ol><h2 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种"></a>Spring 事务中的隔离级别有哪几种</h2><p><strong>TransactionDefinition</strong> 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="Spring-事务中有哪几种事务传播行为"><a href="#Spring-事务中有哪几种事务传播行为" class="headerlink" title="Spring 事务中有哪几种事务传播行为"></a>Spring 事务中有哪几种事务传播行为</h2><p><strong>支持当前事务的情况：</strong></p><ul><li><p>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p></li><li><p>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p></li><li><p>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p><strong>不支持当前事务的情况：</strong></p></li><li><p>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p></li><li><p>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p></li><li><p>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。<br><strong>其他情况：</strong></p></li><li><p>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="2021/05/29/Redis/"/>
      <url>2021/05/29/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis（Remote Dictionary Server）即远程字典服务</p><p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。</p><p>免费和开源！是当下最热门的NoSql 技术之一！也被人们称为架构化数据库</p><h2 id="Redis能干什么"><a href="#Redis能干什么" class="headerlink" title="Redis能干什么"></a>Redis能干什么</h2><ol><li>内存存储、持久化、内存中的数据是断电即失的，所以说持久化很重要！（RDB，AOF）</li><li>效率高、可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（数据浏览量）</li><li>……</li></ol><h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><ol><li>持久化</li><li>多样化数据库</li><li>集群</li><li>事务</li><li>……</li></ol><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>Windows：<a href="https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100">下载地址</a></p><p>下载完成解压</p><p><img src="/2021/05/29/Redis/1.png"></p><p>启动Redis服务器：</p><p>双击运行服务：<code>redis-server.exe</code></p><p><img src="/2021/05/29/Redis/2.png"></p><p>运行成功</p><p>再次运行redis客户端 启动 <code>redis-cli.exe</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; ping  ----&gt; 测试是否连接成功</span><br><span class="line">PONG </span><br><span class="line">127.0.0.1：6379&gt; <span class="built_in">set</span> name xiaoyang  -----&gt; 设置 key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1：6379&gt; get name  ------&gt; 用 key 去寻找 value</span><br><span class="line"><span class="string">&quot;xiaoyang&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>官网下载：<a href="https://redis.io/">地址</a></p><p>下载完成之后导入到 Liunx 的 opt 目录下面</p><p>执行 <code>tar -zxvf redis...</code> 进行解压</p><p>解压完成只要需要安装c++ 环境 <code>yum -y install gcc-c++</code></p><p>安装完成执行 <code>make</code></p><p><img src="/2021/05/29/Redis/3.png"></p><p>执行完成之后在执行一遍</p><p>然后执行 <code>make install</code></p><p><img src="/2021/05/29/Redis/4.png"></p><p>redis 的默认路径在 <code>usr/local/bin</code>目录下面</p><p><img src="/2021/05/29/Redis/5.png"></p><p>移动 <code>redis.config</code> 到 本目录下</p><p><img src="/2021/05/29/Redis/6.png"></p><p>redis默认不是后台启动，我们需要修改配置文件</p><p>找到这个修改为 <code>yes</code></p><p><img src="/2021/05/29/Redis/7.png"></p><p>启动redis 服务</p><p><img src="/2021/05/29/Redis/8.png"></p><p>测试连接</p><p><img src="/2021/05/29/Redis/9.png"></p><p>查看redis服务信息</p><p><img src="/2021/05/29/Redis/10.png"></p><p>关闭redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; shutdown   ---&gt;关闭redis</span><br><span class="line">not connected&gt; exit   ---&gt; 退出</span><br></pre></td></tr></table></figure><h3 id="redis性能测试"><a href="#redis性能测试" class="headerlink" title="redis性能测试"></a>redis性能测试</h3><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">序号</td><td align="left">选项</td><td align="left">描述</td><td align="left">默认值</td></tr><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输 <numreq> 请求</numreq></td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>—csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><p>测试 使用 <code>redis-benchmark</code></p><p>测试 ：100个并发连接， 100000 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.0 -p 6379 -c 100 -n 100000</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; PING_INLINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;                                                     100000 requests completed in 2.31 seconds    ----&gt; 对我们10w请求进行测试  100 parallel clients    -----&gt; 100个并发的客服端  3 bytes payload    ----&gt; 每次写入3个字节  keep alive： 1   ---&gt; 只有一台服务器来处理这些请求，单机性能  host configuration &quot;save&quot;： 3600 1 300 100 60 10000  host configuration &quot;appendonly&quot;： no  multi-thread： no&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SET &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;                                                     100000 requests completed in 2.31 seconds  100 parallel clients  3 bytes payload  keep alive： 1  host configuration &quot;save&quot;： 3600 1 300 100 60 10000  host configuration &quot;appendonly&quot;： no  multi-thread： noLatency by percentile distribution：0.000% &lt;&#x3D; 0.935 milliseconds (cumulative count 1)50.000% &lt;&#x3D; 1.599 milliseconds (cumulative count 50402)75.000% &lt;&#x3D; 1.895 milliseconds (cumulative count 75422)87.500% &lt;&#x3D; 2.039 milliseconds (cumulative count 87552)93.750% &lt;&#x3D; 2.143 milliseconds (cumulative count 93953)96.875% &lt;&#x3D; 2.487 milliseconds (cumulative count 96893)98.438% &lt;&#x3D; 3.607 milliseconds (cumulative count 98439)99.219% &lt;&#x3D; 6.535 milliseconds (cumulative count 99219)99.609% &lt;&#x3D; 12.039 milliseconds (cumulative count 99613)99.805% &lt;&#x3D; 12.583 milliseconds (cumulative count 99805)99.902% &lt;&#x3D; 13.031 milliseconds (cumulative count 99903)99.951% &lt;&#x3D; 13.479 milliseconds (cumulative count 99952)99.976% &lt;&#x3D; 13.775 milliseconds (cumulative count 99976)99.988% &lt;&#x3D; 13.927 milliseconds (cumulative count 99988)99.994% &lt;&#x3D; 14.007 milliseconds (cumulative count 99994)99.997% &lt;&#x3D; 14.039 milliseconds (cumulative count 99997)99.998% &lt;&#x3D; 14.071 milliseconds (cumulative count 99999)99.999% &lt;&#x3D; 14.087 milliseconds (cumulative count 100000)100.000% &lt;&#x3D; 14.087 milliseconds (cumulative count 100000)</span><br></pre></td></tr></table></figure><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/image-20210318154701720.png" alt="image-20210318154701720"></p><h3 id="Redis默认数据库"><a href="#Redis默认数据库" class="headerlink" title="Redis默认数据库"></a>Redis默认数据库</h3><p>Redis默认有16个数据库，默认使用第0个</p><ul><li>select 2 ——&gt; 更换数据库</li><li>dbsize ——-&gt; 查看数据库大小</li><li>keys * ———&gt; 查看数据库所有的key</li><li>flushdb ————&gt; 清空当前数据库</li><li>flushall ———&gt; 清空所有库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-5-centos changanconfig]# redis-cli -p 6379127.0.0.1：6379&gt; pingPONG127.0.0.1：6379&gt; select 2   ----&gt;  更换数据库OK127.0.0.1：6379[2]&gt; dbsize  -----&gt; 查看数据库大小(integer) 0127.0.0.1：6379[2]&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><h4 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h4><ul><li>Redis-key</li><li>String</li><li>List</li><li>Set</li><li>Hash</li><li>Zset</li></ul><h5 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h5><p><code>keys *</code> 查看当前库所有的key</p><p><code>exists name</code> 判断<code>name</code>key 是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move name 1&#96; 移除 &#96;name</span><br></pre></td></tr></table></figure><p><code>expire name 10</code> 设置<code>name</code> 10秒钟之后过期</p><p><code>ttl name</code> 查看过期时间</p><p><code>type name</code> 查看当前 <code>key</code> 的类型</p><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p><code>append</code> 追加字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1：6379&gt; get name&quot;changan&quot;127.0.0.1：6379&gt; append name love    (integer) 11127.0.0.1：6379&gt; get name&quot;changanlove&quot;127.0.0.1：6379&gt; exists name(integer) 1</span><br></pre></td></tr></table></figure><p><code>incr views</code> 给 views 加1</p><p><code>decr views</code> 给 views 减1</p><p><code>incrby views</code> 给 views 加10</p><p><code>decrby views</code> 给 views 减10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; set views 0OK127.0.0.1：6379&gt; get views&quot;0&quot;127.0.0.1：6379&gt; incr views(integer) 1127.0.0.1：6379&gt; decr views(integer) 0127.0.0.1：6379&gt; incrby views 10(integer) 10127.0.0.1：6379&gt; decrby views 10</span><br></pre></td></tr></table></figure><p><code>getrange</code> 范围查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; getrange key1 0 3&quot;hell&quot;127.0.0.1：6379&gt; getrange key1 0 -1&quot;hello，word&quot;127.0.0.1：6379&gt; getrange key1 5 -1&quot;，word&quot;127.0.0.1：6379&gt; getrange key1 5 0&quot;&quot;127.0.0.1：6379&gt; getrange key1 1 -1&quot;ello，word&quot;127.0.0.1：6379&gt; getrange key1 0 -1</span><br></pre></td></tr></table></figure><p><code>setrange</code> 范围修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; setrange key1 1 xx(integer) 10127.0.0.1：6379&gt; keys *1) &quot;key1&quot;127.0.0.1：6379&gt; get key1&quot;hxxlo，word&quot;</span><br></pre></td></tr></table></figure><p>常在分布式锁使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; setex key2 30 &quot;hello&quot;   ---- &gt; 设置过期时间OK127.0.0.1：6379&gt; ttl key2                ---- &gt; 查看剩余时间(integer) 28127.0.0.1：6379&gt; setnx mykey &quot;redis&quot;     ---- &gt; 如果 mykey 不存在，创建 mykey 返回1 (integer) 1127.0.0.1：6379&gt; keys *   1) &quot;key2&quot;2) &quot;key1&quot;3) &quot;mykey&quot;127.0.0.1：6379&gt; ttl key2 (integer) -2127.0.0.1：6379&gt; setnx mykey &quot;MongDB&quot;    ---- &gt; 如果 mykey 存在，就创建失败 返回0(integer) 0127.0.0.1：6379&gt; get mykey&quot;redis&quot;</span><br></pre></td></tr></table></figure><p>批量获取值和设置值</p><p><code>mset</code> 批量设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1：6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;</span><br></pre></td></tr></table></figure><p><code>mget</code> 同时获取多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; mget k1 k2 k31) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;</span><br></pre></td></tr></table></figure><p><code>msetnx</code> 设置多个值 如果一个值设置失败，那么全部失败 （原子性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; msetnx k1 v1 k5 v5(integer) 0</span><br></pre></td></tr></table></figure><p><code>getset</code> 先获取在设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; getset db redis   --&gt; 不存在返回nil并创建(nil)127.0.0.1：6379&gt; get db&quot;redis&quot;127.0.0.1：6379&gt; getset db mongDb  --&gt; 如果存在，返回当前的值，并设置新的值&quot;redis&quot;127.0.0.1：6379&gt; get db&quot;mongDb&quot;</span><br></pre></td></tr></table></figure><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul><li>计数器</li><li>统计多单位数量</li><li>粉丝数</li><li>对象缓存存储</li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>基本数据类型，列表</p><p><code>lpush</code> 储存 《左存储》</p><p><code>rpush</code> 储存 《右存储》</p><p><code>lrange</code> 读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; lpush list one  ---&gt; 给左push(integer) 1127.0.0.1：6379&gt; lpush list two(integer) 2127.0.0.1：6379&gt; lpush list three(integer) 3127.0.0.1：6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1：6379&gt; lrange list 0 11) &quot;three&quot;2) &quot;two&quot;#####################################################################127.0.0.1：6379&gt; rpush list yss(integer) 4127.0.0.1：6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;yss&quot;</span><br></pre></td></tr></table></figure><p><code>lpop</code> ： 左移除</p><p><code>rpop</code> ： 右移除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; lpop list ----&gt; 移除list第一个元素&quot;three&quot;127.0.0.1：6379&gt; rpop list ----&gt; 移除list最后一个元素&quot;yss&quot;127.0.0.1：6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;</span><br></pre></td></tr></table></figure><p><code>lindex</code> 通过下标获取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; lindex list 0&quot;two&quot;127.0.0.1：6379&gt; lindex list 1&quot;one&quot;</span><br></pre></td></tr></table></figure><p><code>llen</code> 获取list的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; llen list(integer) 4</span><br></pre></td></tr></table></figure><p><code>lrem</code> 删除 ‘精确匹配’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;asdfa&quot;4) &quot;9889&quot;5) &quot;9889&quot;127.0.0.1：6379&gt; lrem list 1 asdfa  ----- &gt; 删除 1个 asdfa(integer) 1127.0.0.1：6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;9889&quot;4) &quot;9889&quot;127.0.0.1：6379&gt; rpush list 9889(integer) 4127.0.0.1：6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;9889&quot;4) &quot;9889&quot;127.0.0.1：6379&gt; lrem list 2 9889   ------ &gt; 删除 2个 9889(integer) 2127.0.0.1：6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;</span><br></pre></td></tr></table></figure><p><code>ltrim</code> 修剪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1：6379&gt; rpush mylist &quot;hello1&quot;(integer) 2127.0.0.1：6379&gt; rpush mylist &quot;hello2&quot;(integer) 3127.0.0.1：6379&gt; rpush mylist &quot;hello3&quot;(integer) 4127.0.0.1：6379&gt; ltrim mylist 1 2   ----- &gt; 通过下标截取指定长度OK127.0.0.1：6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><p><code>rpoplpush</code> 移除列表的最后一个元素 并移动到新的列表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;3) &quot;hello3&quot;127.0.0.1：6379&gt; rpoplpush mylist myotherlist&quot;hello3&quot;127.0.0.1：6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;127.0.0.1：6379&gt; lrange myotherlist 0 -11) &quot;hello3&quot;</span><br></pre></td></tr></table></figure><p><code>lset</code> 将列表中指定下标的值替换为另外一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; exists list   --- &gt;  判断是否有这个集合(integer) 0127.0.0.1：6379&gt; lset list 0 item   ----- &gt; 给list的第0个下标添加 item(error) ERR no such key    ---&gt; 报错，添加失败 没有这个list127.0.0.1：6379&gt; lpush list value1  ------ &gt; 创建 list(integer) 1127.0.0.1：6379&gt; lrange list 0 -11) &quot;value1&quot;127.0.0.1：6379&gt; lset list 0 item   ----- &gt; 再次用 lset 覆盖 刚创建那个list的第0个下标OK127.0.0.1：6379&gt; lrange list 0 -11) &quot;item&quot;127.0.0.1：6379&gt; lset list 1 item  -----&gt; 如果给list添加值 这个下标不存在那么就会报错(error) ERR index out of range</span><br></pre></td></tr></table></figure><p><code>linsert</code> 将某一个具体的值插入列表某个元素的前后</p><p>==参数==：``before<code>左、前</code>after` 右、后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1：6379&gt; rpush mylist &quot;word&quot;(integer) 2&#x2F;&#x2F; before127.0.0.1：6379&gt; linsert mylist before &quot;word&quot; &quot;other&quot;  (integer) 3127.0.0.1：6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;word&quot;&#x2F;&#x2F; after127.0.0.1：6379&gt; linsert mylist after &quot;word&quot; &quot;king&quot;(integer) 4127.0.0.1：6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;word&quot;4) &quot;king&quot;</span><br></pre></td></tr></table></figure><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ul><li><p>set实际是一个链表，before Node after，left ，right 都可以插入值</p></li><li><p>如果key 不存在，创建新的链表</p></li><li><p>如果key 存在，新增内容</p></li><li><p>如果移除了所有的值，空链表，也代表不存在</p></li><li><p>在两边插入或改动值，效率最高！中间元素，相对来说效率会第一点</p><p>可以用来 消息排队！ 消息队列（Lpush Rpop） 左进右出 ，栈（Lpush Lpop）左进左出</p></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>set中的值不能重复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd</span><br><span class="line">smembers</span><br><span class="line">sismember</span><br><span class="line">scard</span><br><span class="line">127.0.0.1：6379&gt; sadd myset hello   ----&gt; 给集合添加值(integer) 1127.0.0.1：6379&gt; sadd myset changan  (integer) 1127.0.0.1：6379&gt; sadd myset king(integer) 1127.0.0.1：6379&gt; SMEMBERS myset    -----&gt; 查看当前集合元素1) &quot;king&quot;2) &quot;changan&quot;3) &quot;hello&quot;127.0.0.1：6379&gt; SISMEMBER myset hello   -----&gt; 查看集合是否有hello  有的话返回1 没有就是0(integer) 1127.0.0.1：6379&gt; SISMEMBER myset word(integer) 0127.0.0.1：6379&gt; scard myset   ------&gt; 获取当前集合的个数(integer) 3127.0.0.1：6379&gt; srem myset hello   -----&gt; 删除集合指定的值(integer) 1127.0.0.1：6379&gt; SMEMBERS myset1) &quot;king&quot;2) &quot;changan&quot;</span><br></pre></td></tr></table></figure><p><code>SRANDMEMBER</code> 随机从集合中筛选一个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; SRANDMEMBER myset&quot;king&quot;127.0.0.1：6379&gt; SRANDMEMBER myset&quot;king&quot;127.0.0.1：6379&gt; SRANDMEMBER myset&quot;king&quot;127.0.0.1：6379&gt; SRANDMEMBER myset&quot;king&quot;127.0.0.1：6379&gt; SRANDMEMBER myset&quot;changan&quot;</span><br></pre></td></tr></table></figure><p><code>spop</code> 随机删除一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; SMEMBERS myset1) &quot;king&quot;2) &quot;changan&quot;127.0.0.1：6379&gt; spop myset&quot;king&quot;127.0.0.1：6379&gt; SMEMBERS myset1) &quot;changan&quot;</span><br></pre></td></tr></table></figure><p><code>smove</code>将一个指定的值移动到另外一个set集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; sadd myset hello(integer) 1127.0.0.1：6379&gt; sadd myset word(integer) 1127.0.0.1：6379&gt; sadd myset changanking(integer) 1127.0.0.1：6379&gt; sadd myset king(integer) 1127.0.0.1：6379&gt; sadd myset2 set2(integer) 1127.0.0.1：6379&gt; smove myset myset2 changanking    (integer) 1127.0.0.1：6379&gt; SMEMBERS myset1) &quot;word&quot;2) &quot;hello&quot;3) &quot;changan&quot;4) &quot;king&quot;127.0.0.1：6379&gt; SMEMBERS myset21) &quot;changanking&quot;2) &quot;set2&quot;</span><br></pre></td></tr></table></figure><p><code>SDIFF</code> 查看2个集合的差集</p><p><code>SINTER</code> 查看2个集合的交集 共同好友就可以实现</p><p><code>SUNION</code> 查看2个集合的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; sadd key1 a(integer) 1127.0.0.1：6379&gt; sadd key1 b(integer) 1127.0.0.1：6379&gt; sadd key1 c(integer) 1127.0.0.1：6379&gt; sadd key2 c(integer) 1127.0.0.1：6379&gt; sadd key2 d(integer) 1127.0.0.1：6379&gt; sadd key2 e(integer) 1127.0.0.1：6379&gt; SDIFF key1 key21) &quot;a&quot;2) &quot;b&quot;127.0.0.1：6379&gt; SINTER key1 key21) &quot;c&quot;127.0.0.1：6379&gt; SUNION key1 key21) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;d&quot;5) &quot;e&quot;</span><br></pre></td></tr></table></figure><h6 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h6><p>微博 ，A用户将所有的关注的人放在一个set集合中，将他的粉丝也放在一个集合中</p><p>共同关注，共同爱好，二度好友，推荐好友！</p><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>Map集合，Key—Value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hset map k changan   ----&gt;  给map存一个k-v(integer) 1127.0.0.1：6379&gt; hget map k           ----&gt;  通过k取值&quot;changan&quot;127.0.0.1：6379&gt; hmset map y king u anuyn  ----&gt;  给map存多个值OK 127.0.0.1：6379&gt; hmget map y u           ----&gt;  获取map多个值1) &quot;king&quot;2) &quot;anuyn&quot;127.0.0.1：6379&gt; hgetall map              ------&gt; 查看map所有的kv1) &quot;k&quot;2) &quot;changan&quot;3) &quot;y&quot;4) &quot;king&quot;5) &quot;u&quot;6) &quot;anuyn&quot;</span><br></pre></td></tr></table></figure><p><code>hdel</code> 删除指定的kv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hdel map u     -----&gt; 删除指定的 k(integer) 1127.0.0.1：6379&gt; hgetall map1) &quot;k&quot;2) &quot;changan&quot;3) &quot;y&quot;4) &quot;king&quot;</span><br></pre></td></tr></table></figure><p><code>hlen</code> 查询集合有几组kv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hlen map(integer) 2</span><br></pre></td></tr></table></figure><p><code>HEXISTS</code> 查看集合的k是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; HEXISTS map k(integer) 1127.0.0.1：6379&gt; HEXISTS map u(integer) 0</span><br></pre></td></tr></table></figure><p><code>hkeys</code> 查看所有的key</p><p><code>hvals</code> 查看所有的value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hkeys map1) &quot;k&quot;2) &quot;y&quot;127.0.0.1：6379&gt; hvals map1) &quot;changan&quot;2) &quot;king&quot;</span><br></pre></td></tr></table></figure><p><code>HINCRBY</code> 指定增量</p><p><code>hsetnx</code> 创建一个集合 如果这个集合没有数据 就放入数据 返回1 如果有数据 那么返回0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hset myhash field3 5    ----- &gt;&gt;&gt; 指定增量(integer) 1127.0.0.1：6379&gt; HINCRBY myhash field3 1   ------&gt;&gt;&gt; 给数据加一(integer) 6127.0.0.1：6379&gt; HINCRBY myhash field3 -1  ------&gt;&gt;&gt;&gt; 给数据减一(integer) 5127.0.0.1：6379&gt; hsetnx myhash field4 hello  -------&gt; 创建一个集合 如果存在则不能设置 返回1(integer) 1127.0.0.1：6379&gt; hsetnx myhash field4 world   ----&gt;&gt; 创建一个集合 如果存在则不能设置 返回0(integer) 0</span><br></pre></td></tr></table></figure><p>hash可以用于存储对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; hset user：1 name changan(integer) 1127.0.0.1：6379&gt; hget user：1 name&quot;changan&quot;127.0.0.1：6379&gt; hset user：1 age 23(integer) 1127.0.0.1：6379&gt; hget user：1 age&quot;23&quot;</span><br></pre></td></tr></table></figure><h6 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h6><p>hash 用来处理变更的数据 user name age ，尤其是用户信息之类，经常变动的信息！ hash 更适合与对象的存储，String 适合字符串的存储！</p><h5 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h5><p>在set的基础上加了一个值</p><h6 id="api："><a href="#api：" class="headerlink" title="api："></a>api：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; zadd myset 1 one     -----&gt; 创建一个值(integer) 1127.0.0.1：6379&gt; zadd myset 2 two 3 three   -----&gt;  创建2个值(integer) 2127.0.0.1：6379&gt; zrange myset 0 -1   ------&gt; 获取myset 里的数据1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;</span><br></pre></td></tr></table></figure><p><code>zrangebyscore</code> ： 从低到高 进行排序</p><p><code>zrevrange</code> ： 从高到低 进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; zadd salary 5000 xiaohong(integer) 1127.0.0.1：6379&gt; zadd salary 2500 xiaoming(integer) 1127.0.0.1：6379&gt; zadd salary 500 zhangsan(integer) 1127.0.0.1：6379&gt; zrangebyscore salary -inf +inf   ---- &gt; 通过集合salary 的 钱数排序 -inf 负无穷  +inf 正无穷    从低到高1) &quot;zhangsan&quot;2) &quot;xiaoming&quot;3) &quot;xiaohong&quot;127.0.0.1：6379&gt; zrevrange salary 0 -11) &quot;xiaoming&quot;2) &quot;zhangsan&quot;127.0.0.1：6379&gt; zrangebyscore salary -inf +inf withscores  --&gt;&gt; 查询出来所有数据 WITHSCORES会返回元素和其分数1) &quot;zhangsan&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;xiaohong&quot;6) &quot;5000&quot;127.0.0.1：6379&gt; zrangebyscore salary -inf 2500 withscores1) &quot;zhangsan&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;</span><br></pre></td></tr></table></figure><p><code>zrem</code> 移除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; zrange salary 0 -11) &quot;zhangsan&quot;2) &quot;xiaoming&quot;3) &quot;xiaohong&quot;127.0.0.1：6379&gt; zrem salary xiaohong(integer) 1</span><br></pre></td></tr></table></figure><p><code>zcard</code> 获取集合中的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; zcard salary(integer) 2</span><br></pre></td></tr></table></figure><p><code>zcount</code> 获取指定区间的成员数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; zadd myset 1 &quot;hello&quot; 2 &quot;word&quot; 3 &quot;changan&quot;(integer) 3127.0.0.1：6379&gt; zcount myset 1 2(integer) 2127.0.0.1：6379&gt; zcount myset 1 3(integer) 3</span><br></pre></td></tr></table></figure><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>set 排序 存储班级成绩，工资排序</p><p>普通消息 1、重要消息 2 带权重进行判断</p><p>排行榜应用实现 取 Top N测试</p><h4 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h4><h5 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h5><p>Redis 的 Geo 可以去实现 推算2地之间的距离，推算地理位置信息 …… ！</p><p>测试数据网站：http：//<a href="http://www.toolzl.com/tools/gps.html">www.toolzl.com/tools/gps.html</a></p><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/image-20210415171238885.png" alt="image-20210415171238885"></p><blockquote><p>Geoadd 添加地理位置</p><p>~ 2极地区无法直接添加，我们一般会下载城市数据，用Java程序导入</p></blockquote><p>==将指定的地理空间位置（纬度、经度、名称）添加到指定的<code>key</code>中==</p><ul><li>有效经度为-180至180度。</li><li>有效纬度为-85.05112878至85.05112878度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; geoadd china：city 116.40 39.90 beijing(integer) 1127.0.0.1：6379&gt; geoadd china：city 121.47 31.23 shanghai(integer) 1127.0.0.1：6379&gt; geoadd china：city 106.50 29.53 chongqi 114.05 22.52 shenzhen(integer) 2127.0.0.1：6379&gt; geoadd china：city 120.16 30.24 hangzhou 108.96 34.26 xian (integer) 2</span><br></pre></td></tr></table></figure><blockquote><p>geopos 查询地理位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; geopos china：city beijing1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;127.0.0.1：6379&gt; geopos china：city xian1) 1) &quot;108.96000176668167114&quot;   2) &quot;34.25999964418929977&quot;</span><br></pre></td></tr></table></figure><blockquote><p>geodist</p></blockquote><p>返回两个给定位置之间的距离。</p><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p><p>指定单位的参数 unit 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; geodist china：city beijing xian km   北京到西安的直线距离&quot;910.0565&quot;127.0.0.1：6379&gt; geodist china：city beijing shanghai km  北京带上海的直线距离&quot;1067.3788&quot;</span><br></pre></td></tr></table></figure><blockquote><p>附近的人</p></blockquote><p>半径搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; georadius china：city 110 30 1000 km  以 110，30的地理坐标 查询 1000km 内的城市1) &quot;chongqi&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;127.0.0.1：6379&gt; georadius china：city 110 30 500 km 以 110，30的地理坐标 查询 500km 内的城市1) &quot;chongqi&quot;2) &quot;xian&quot;127.0.0.1：6379&gt; georadius china：city 110 30 500 km withdist   到中心的直线距离1) 1) &quot;chongqi&quot;   2) &quot;341.9374&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;127.0.0.1：6379&gt; georadius china：city 110 30 500 km withcoord   经纬度1) 1) &quot;chongqi&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1：6379&gt; georadius china：city 110 30 500 km withcoord count 1  查询指定数量的1) 1) &quot;chongqi&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;</span><br></pre></td></tr></table></figure><blockquote><p>GEORADIUSBYMEMBER</p></blockquote><p>找出位于指定元素周围的其他元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; GEORADIUSBYMEMBER china：city beijing 1000 km1) &quot;beijing&quot;2) &quot;xian&quot;127.0.0.1：6379&gt; GEORADIUSBYMEMBER china：city beijing 500 km1) &quot;beijing&quot;</span><br></pre></td></tr></table></figure><p>删除、查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; zrange china：city 0 -1   查看所有1) &quot;chongqi&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing&quot;127.0.0.1：6379&gt; zrem china：city beijing  删除(integer) 1127.0.0.1：6379&gt; zrange china：city 0 -11) &quot;chongqi&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;</span><br></pre></td></tr></table></figure><h5 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog 基数统计"></a>Hyperloglog 基数统计</h5><p>什么是基数！</p><p>A{ 1、3、5、7、8、7 }</p><p>B{ 1、3、5、7、8 }</p><p>基数 （不重复的元素）= 5，可以接收误差！</p><blockquote><p>简介</p></blockquote><p><code>pfadd</code> ：添加数据</p><p><code>pfcount</code> ：查询数据</p><p><code>pfmerge</code> ：合并数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; pfadd mykey a b c d e f g h i j k(integer) 1127.0.0.1：6379&gt; pfcount mykey(integer) 11127.0.0.1：6379&gt; pfadd mykey2 b c d t y o p(integer) 1127.0.0.1：6379&gt; pfcount mykey2(integer) 7127.0.0.1：6379&gt; pfmerge mykey3 mykey mykey2OK127.0.0.1：6379&gt; pfcount mykey3(integer) 14</span><br></pre></td></tr></table></figure><h5 id="Bitmaps（位图）-位存储"><a href="#Bitmaps（位图）-位存储" class="headerlink" title="Bitmaps（位图） 位存储"></a>Bitmaps（位图） 位存储</h5><p>只要是2位数的 数据结构就可以用</p><p>如：登录、未登录 活跃、不活跃</p><p>设置或者清空key的value(字符串)在offset处的bit值。</p><p>那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value</p><blockquote><p>测试</p></blockquote><p>测试打卡记录 在2021年4月15日没有打卡等</p><p><code>setbit</code> 存值</p><p><code>getbit</code> 取值</p><p><code>bitcount</code> 查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; setbit sign 20210415 0 (integer) 0127.0.0.1：6379&gt; setbit sign 20210416 1(integer) 0127.0.0.1：6379&gt; setbit sign 20210414 0(integer) 0127.0.0.1：6379&gt; setbit sign 20210413 1(integer) 0127.0.0.1：6379&gt; setbit sign 20210412 1(integer) 0127.0.0.1：6379&gt; setbit sign 20210417 1(integer) 0127.0.0.1：6379&gt; getbit sign 20210416(integer) 1127.0.0.1：6379&gt; getbit sign 20210415(integer) 0127.0.0.1：6379&gt; bitcount sign(integer) 4</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis 事务本质：一组命令的集合！</p><p>一个事务中所有的命令都会被序列化，在事务执行过程中，会按照顺序执行！</p><p>==一次性、序列型、非它性、==</p><p>==Redis事务没有隔离级别的概念==</p><p>==Redis 单条命令是保存原子性的、但是事务不保证原子性==</p><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！—Exec</p><p>Redis的事务：</p><ul><li>开启事务 （multi）</li><li>命令入队 （ ）</li><li>执行命令 （exec）</li></ul><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; multi     &#x2F;&#x2F; &gt; 开启事务OK127.0.0.1：6379(TX)&gt; set k1 1    &#x2F;&#x2F; 命令入队QUEUED127.0.0.1：6379(TX)&gt; set k1 2QUEUED127.0.0.1：6379(TX)&gt; set k1 3QUEUED127.0.0.1：6379(TX)&gt; set k2 2QUEUED127.0.0.1：6379(TX)&gt; set k3 4QUEUED127.0.0.1：6379(TX)&gt; set k4 6QUEUED127.0.0.1：6379(TX)&gt; get k4QUEUED127.0.0.1：6379(TX)&gt; set k7 9QUEUED127.0.0.1：6379(TX)&gt; exec      &#x2F;&#x2F;  执行事务1) OK2) OK3) OK4) OK5) OK6) OK7) &quot;6&quot;8) OK</span><br></pre></td></tr></table></figure><p>放弃事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; multi    &#x2F;&#x2F; 开启事务OK127.0.0.1：6379(TX)&gt; set key7 7QUEUED127.0.0.1：6379(TX)&gt; discard    &#x2F;&#x2F; 取消事务OK127.0.0.1：6379&gt; get key7(nil)</span><br></pre></td></tr></table></figure><p>编译型异常： 命令错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; multiOK127.0.0.1：6379(TX)&gt; set k1 2QUEUED127.0.0.1：6379(TX)&gt; set k2 4QUEUED127.0.0.1：6379(TX)&gt; set k4 5QUEUED127.0.0.1：6379(TX)&gt; getset k7 8QUEUED127.0.0.1：6379(TX)&gt; getset k9       &#x2F;&#x2F;错误语法(error) ERR wrong number of arguments for &#39;getset&#39; command127.0.0.1：6379(TX)&gt; set k8 9QUEUED127.0.0.1：6379(TX)&gt; exec(error) EXECABORT Transaction discarded because of previous errors.     &#x2F;*提示语法错误，所有命令都不执行 **&#x2F;127.0.0.1：6379&gt; get k4(nil)</span><br></pre></td></tr></table></figure><p>运行时异常：如果命令中存在错误，不会影响其他命令执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; set k1 7OK127.0.0.1：6379&gt; set k2 &quot;j9&quot;OK127.0.0.1：6379&gt; multiOK127.0.0.1：6379(TX)&gt; incr k2    &#x2F;&#x2F; 会执行失败QUEUED127.0.0.1：6379(TX)&gt; set k3 3QUEUED127.0.0.1：6379(TX)&gt; set k4 5QUEUED127.0.0.1：6379(TX)&gt; get k4QUEUED127.0.0.1：6379(TX)&gt; exec1) (error) ERR value is not an integer or out of range        &#x2F;&#x2F; 虽然第一条命令执行失败了后面的命令会继续执行2) OK3) OK4) &quot;5&quot;127.0.0.1：6379&gt; get k3&quot;3&quot;127.0.0.1：6379&gt; get k4&quot;5&quot;</span><br></pre></td></tr></table></figure><blockquote><p>监控</p></blockquote><p><strong>悲观锁：</strong></p><p>认为什么时候都会出现问题，无论做什么都会加锁</p><p><strong>乐观锁：</strong></p><ul><li>认为什么时候都不会出现问题，所以不会上锁、可以更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取 version</li><li>更新的时候比较 version</li></ul><p>数据测试：</p><p>单线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; set money 100    &#x2F;&#x2F; 设置金钱是100OK127.0.0.1：6379&gt; set out 0        &#x2F;&#x2F; 设置金钱是0OK127.0.0.1：6379&gt; watch money      &#x2F;&#x2F; 给money上锁OK127.0.0.1：6379&gt; multi     &#x2F;&#x2F; 开启事务OK127.0.0.1：6379(TX)&gt; decrby money 20    &#x2F;&#x2F; money金钱减 20QUEUED127.0.0.1：6379(TX)&gt; incrby out 20      &#x2F;&#x2F; out 加 220QUEUED127.0.0.1：6379(TX)&gt; exec1) (integer) 802) (integer) 20</span><br></pre></td></tr></table></figure><p>多线程</p><p>使用 <code>watch</code> 来当做Redis的乐观锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程 1 127.0.0.1：6379&gt; watch money      &#x2F;&#x2F; 开启监控OK127.0.0.1：6379&gt; multi            &#x2F;&#x2F; 开启事务OK127.0.0.1：6379(TX)&gt; decrby money 10    &#x2F;&#x2F; 金币减10QUEUED127.0.0.1：6379(TX)&gt; incrby out 10      &#x2F;&#x2F; 金币加10QUEUED    &#x2F;&#x2F; 线程 2    127.0.0.1：6379&gt; incrby money 1000   &#x2F;&#x2F; 线程2 给这个用户 充值 1000    (integer) 1080&#x2F;&#x2F; 线程 1    127.0.0.1：6379(TX)&gt; exec  &#x2F;&#x2F; 线程 1 继续执行 然后就会执行失败(nil)</span><br></pre></td></tr></table></figure><p>如果修改失败获取最新的值即可</p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：6379&gt; unwatch    &#x2F;&#x2F; 放弃旧的锁OK127.0.0.1：6379&gt; watch money   &#x2F;&#x2F; 加新锁OK127.0.0.1：6379&gt; multi    &#x2F;&#x2F; 开启事务OK127.0.0.1：6379(TX)&gt; decrby money 100QUEUED127.0.0.1：6379(TX)&gt; incrby out 100QUEUED127.0.0.1：6379(TX)&gt; exec1) (integer) 10002) (integer) 120</span><br></pre></td></tr></table></figure><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>什么是Jedis</p><p>Jedis是Redis 推荐使用的Java开发工具！使用Java操作中间件！</p><blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></blockquote><h5 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https：&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.5.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- fastjson--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.76&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2、编码测试"><a href="#2、编码测试" class="headerlink" title="2、编码测试"></a>2、编码测试</h5><h6 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;        Jedis jedis &#x3D; new Jedis(&quot;XXXXXXX&quot;，6379); &#x2F;&#x2F; ip地址及端口号        jedis.auth(&quot;---&quot;); &#x2F;&#x2F;redis 密码        System.out.println(jedis.ping());&#125;</span><br></pre></td></tr></table></figure><p>本地访问 直接 <code>Jedis jedis = new Jedis(&quot;127.0.0.1&quot;，6379);</code></p><p>输出 <code>PONG</code> 连接成功</p><h6 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h6><p>……</p><p>事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RedisApi api &#x3D; new RedisApi();Jedis jedis &#x3D; api.connection();jedis.flushDB();JSONObject jsonObject &#x3D; new JSONObject();jsonObject.put(&quot;hello&quot;，&quot;word&quot;);jsonObject.put(&quot;name&quot;，&quot;changan&quot;);Transaction multi &#x3D; jedis.multi();String toString &#x3D; jsonObject.toJSONString();try &#123;    multi.set(&quot;user1&quot;，toString);        &#x2F;&#x2F;注意事务执行的话要用事务 multi.set 而不是jedis.set    multi.set(&quot;user2&quot;，toString);    &#x2F;&#x2F; int i &#x3D; 1&#x2F;0;    multi.exec();&#125;catch (Exception e)&#123;    multi.discard();    e.printStackTrace();&#125;finally &#123;    System.out.println(jedis.get(&quot;user1&quot;));    System.out.println(jedis.get(&quot;user2&quot;));&#125;</span><br></pre></td></tr></table></figure><h6 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.close()</span><br></pre></td></tr></table></figure><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>说明：在SpringBoot2.x 之后 Jedis 被替换成为了 lettuce</p><p>区别：</p><ul><li>Jedis ： 采用直连方式 、是不安全的，要避免安全隐患要采用 Jedis的pool连接池管理！ <strong><u>像BIO</u></strong></li><li>lettuce ： 采用netty 实例可以在多个进程<strong>享、不存在线程不安全问题 <u>**像NIO</u></strong></li></ul><h4 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h4><ol><li><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置Redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring：  redis：    host： 服务器地址    port： 6379    password： redis密码</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Resourceprivate RedisTemplate redisTemplate;@Testvoid contextLoads() &#123;    RedisConnection connection &#x3D; Objects.requireNonNull(redisTemplate.getConnectionFactory()).getConnection();    System.out.println(connection.ping());    &#x2F;&#x2F; 测试链接是否成功    redisTemplate.opsForValue().set(&quot;key&quot;，&quot;changan&quot;);   &#x2F;&#x2F;  操纵字符串 set 一个值    Object key &#x3D; redisTemplate.opsForValue().get(&quot;key&quot;);  &#x2F;&#x2F; 获取值    System.out.println(key);&#125;</span><br></pre></td></tr></table></figure><ul><li><p>redisTemplate.opsForValue() 操作字符串</p></li><li><p>redisTemplate.opsForList() 操作list</p></li><li><p>等</p></li><li><p>```<br>connection.close();    // 关闭链接connection.flushAll(); // 清空所有数据库的所有 keyconnection.flushDb();  // 清空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 测试</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Testpublic void UserTest() throws JsonProcessingException {    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();    connection.flushDb();    User user = new User(“长安”，23);    String s = new ObjectMapper().writeValueAsString(user);   // 转化为Json 数据    redisTemplate.opsForValue().set(“user”，s);    System.out.println(redisTemplate.opsForValue().get(“user”));}// 输出结果  {“name”：”长安”，”age”：23}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果我们直接传对象没有序列化 ，会报错</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Testpublic void UserTest() throws JsonProcessingException {    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();    connection.flushDb();    User user = new User(“长安”，23);    redisTemplate.opsForValue().set(“user”，user);    System.out.println(redisTemplate.opsForValue().get(“user”));}//Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException： Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException： DefaultSerializer requires a Serializable payload but received an object of type [com.changan.model.User]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果要传递对象要序列化</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class User implements Serializable {    private String name;    private int age;}// 结果  User(name=长安， age=23)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编写一个自己的 Redis 序列化</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Configurationpublic class RedisConfig {    // 配置自己的Redis  固定模板    @Bean    public RedisTemplate&lt;String， Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {        // 我们为了自己开发方便，一般直接使用&lt;String，Object&gt;        RedisTemplate&lt;String， Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        // Json序列化配置        Jackson2JsonRedisSerializer<Object> jsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL， JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jsonRedisSerializer.setObjectMapper(objectMapper);        // String 的序列化        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key 采用String 方式序列化        template.setKeySerializer(stringRedisSerializer);        // hash 的key 采用String 方式序列化        template.setHashKeySerializer(stringRedisSerializer);        // Value 采用Json 序列化        template.setValueSerializer(jsonRedisSerializer);        // hash 的 Value 采用Json 序列化        template.setHashValueSerializer(jsonRedisSerializer);        template.afterPropertiesSet();        return template;    }}</Object></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Redis.conf详解</span><br><span class="line"></span><br><span class="line">#### 单位</span><br><span class="line"></span><br><span class="line">![image-20210419092419685](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210419092419.png)</span><br><span class="line"></span><br><span class="line">#### 包含 INCLUDES</span><br><span class="line"></span><br><span class="line">![image-20210420092826846](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420092834.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里包括一个或多个其他配置文件。这很有用，如果你有一个标准的模板，去所有的Redis服务器，但也需要自定义一些服务器设置。包括文件可以包括其他文件，所以明智地使用这个。注意选项“include”不会被命令“CONFIG REWRITE”重写从admin或Redis哨兵。因为Redis总是使用最后处理的line作为配置指令的值，你最好放包含在这个文件的开头，以避免在运行时覆盖配置更改。如果你有兴趣使用include覆盖配置options，最好使用include作为最后一行。include /path/to/local.confinclude /path/to/other.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 网络 NETWORK</span><br><span class="line"></span><br><span class="line">![image-20210420093312397](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420093312.png)</span><br><span class="line"></span><br><span class="line">&#96;bind 0.0.0.0&#96; 对所有人开放 可以指定单个或多个ip</span><br><span class="line"></span><br><span class="line">指定多个ip 访问 ip 用空格 隔开</span><br><span class="line"></span><br><span class="line">![image-20210420093502139](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420093502.png)</span><br><span class="line"></span><br><span class="line">&#96;protected-mode yes&#96; 开启受保护模式</span><br><span class="line"></span><br><span class="line">&#96;prot 6379&#96; 默认端口号</span><br><span class="line"></span><br><span class="line">#### 通用 GENERAL</span><br><span class="line"></span><br><span class="line">&#96;daemonize yes&#96; 以守护进程的方式运行，默认是 no 我们需要自己设置为yes</span><br><span class="line"></span><br><span class="line">&#96;pidfile &#x2F;www&#x2F;server&#x2F;redis&#x2F;redis.pid&#96; 如果是守护进程方式运行，我们需要指定一个pid文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Specify-the-server-verbosity-level-This-can-be-one-of：-debug-a-lot-of-information，-useful-for-development-testing-verbose-many-rarely-useful-info，-but-not-a-mess-like-the-debug-level-notice-moderately-verbose，-what-you-want-in-production-probably-warning-only-very-important-critical-messages-are-logged-loglevel-notice-指定服务器详细级别。-这个可以是：-debug-大量信息，对开发-测试有用-verbose-很多很少有用的信息，但不像调试级别那样混乱-notice-有点冗长，可能是在生产中需要的内容-warning-只记录非常重要-关键的消息"><a href="#Specify-the-server-verbosity-level-This-can-be-one-of：-debug-a-lot-of-information，-useful-for-development-testing-verbose-many-rarely-useful-info，-but-not-a-mess-like-the-debug-level-notice-moderately-verbose，-what-you-want-in-production-probably-warning-only-very-important-critical-messages-are-logged-loglevel-notice-指定服务器详细级别。-这个可以是：-debug-大量信息，对开发-测试有用-verbose-很多很少有用的信息，但不像调试级别那样混乱-notice-有点冗长，可能是在生产中需要的内容-warning-只记录非常重要-关键的消息" class="headerlink" title="Specify the server verbosity level.# This can be one of：# debug (a lot of information， useful for development/testing)# verbose (many rarely useful info， but not a mess like the debug level)# notice (moderately verbose， what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice#指定服务器详细级别。#这个可以是：# debug(大量信息，对开发/测试有用)# verbose(很多很少有用的信息，但不像调试级别那样混乱)# notice(有点冗长，可能是在生产中需要的内容)# warning(只记录非常重要/关键的消息)"></a>Specify the server verbosity level.# This can be one of：# debug (a lot of information， useful for development/testing)# verbose (many rarely useful info， but not a mess like the debug level)# notice (moderately verbose， what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice#指定服务器详细级别。#这个可以是：# debug(大量信息，对开发/测试有用)# verbose(很多很少有用的信息，但不像调试级别那样混乱)# notice(有点冗长，可能是在生产中需要的内容)# warning(只记录非常重要/关键的消息)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;logfile &quot;&#x2F;www&#x2F;server&#x2F;redis&#x2F;redis.log&quot;&#96; 日志的文件位置</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Set-the-number-of-databases-The-default-database-is-DB-0，-you-can-select-a-different-one-on-a-per-connection-basis-using-SELECT-where-dbid-is-a-number-between-0-and-‘databases’-1databases-16-设置数据库个数。默认数据库为“DB-0”，可选择-在每个连接上使用SELECT-where-dbid是一个介于0和’databases’-1之间的数字"><a href="#Set-the-number-of-databases-The-default-database-is-DB-0，-you-can-select-a-different-one-on-a-per-connection-basis-using-SELECT-where-dbid-is-a-number-between-0-and-‘databases’-1databases-16-设置数据库个数。默认数据库为“DB-0”，可选择-在每个连接上使用SELECT-where-dbid是一个介于0和’databases’-1之间的数字" class="headerlink" title="Set the number of databases. The default database is DB 0， you can select# a different one on a per-connection basis using SELECT  where# dbid is a number between 0 and ‘databases’-1databases 16#设置数据库个数。默认数据库为“DB 0”，可选择#在每个连接上使用SELECT where# dbid是一个介于0和’databases’-1之间的数字"></a>Set the number of databases. The default database is DB 0， you can select# a different one on a per-connection basis using SELECT <dbid> where# dbid is a number between 0 and ‘databases’-1databases 16#设置数据库个数。默认数据库为“DB 0”，可选择#在每个连接上使用SELECT where# dbid是一个介于0和’databases’-1之间的数字</dbid></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;databases&#96; 默认的数据库数量 16 个</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="By-default-Redis-shows-an-ASCII-art-logo-only-when-started-to-log-to-the-standard-output-and-if-the-standard-output-is-a-TTY-Basically-this-means-that-normally-a-logo-is-displayed-only-in-interactive-sessions-However-it-is-possible-to-force-the-pre-4-0-behavior-and-always-show-a-ASCII-art-logo-in-startup-logs-by-setting-the-following-option-to-yes-always-show-logo-yes"><a href="#By-default-Redis-shows-an-ASCII-art-logo-only-when-started-to-log-to-the-standard-output-and-if-the-standard-output-is-a-TTY-Basically-this-means-that-normally-a-logo-is-displayed-only-in-interactive-sessions-However-it-is-possible-to-force-the-pre-4-0-behavior-and-always-show-a-ASCII-art-logo-in-startup-logs-by-setting-the-following-option-to-yes-always-show-logo-yes" class="headerlink" title="By default Redis shows an ASCII art logo only when started to log to the# standard output and if the standard output is a TTY. Basically this means# that normally a logo is displayed only in interactive sessions.## However it is possible to force the pre-4.0 behavior and always show a# ASCII art logo in startup logs by setting the following option to yes.always-show-logo yes"></a>By default Redis shows an ASCII art logo only when started to log to the# standard output and if the standard output is a TTY. Basically this means# that normally a logo is displayed only in interactive sessions.## However it is possible to force the pre-4.0 behavior and always show a# ASCII art logo in startup logs by setting the following option to yes.always-show-logo yes</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;always-show-logo yes&#96; 是否显示log 默认为开启</span><br><span class="line"></span><br><span class="line">#### 快照 SNAPSHOTTING</span><br><span class="line"></span><br><span class="line">![image-20210420095513960](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420095514.png)</span><br><span class="line"></span><br><span class="line">持久化数据 因为 Redis是内存数据库 如果断电等因素 会失去数据 所以我们需要在一定时间里 持久化数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 在 900s 内 有 1个key进行了操作 那么将会持久化一下save 900 1// 在 300s 内 有 10个key进行了操作 那么将会持久化一下save 300 10// 在 60s 内 有 1w个key进行了操作 那么将会持久化一下save 60 10000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210420095830031](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420095830.png)</span><br><span class="line"></span><br><span class="line">&#96;stop-writes-on-bgsave-error yes&#96; 持久化 出错了是否继续工作 默认继续</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Compress-string-objects-using-LZF-when-dump-rdb-databases-For-default-that’s-set-to-‘yes’-as-it’s-almost-always-a-win-If-you-want-to-save-some-CPU-in-the-saving-child-set-it-to-‘no’-but-the-dataset-will-likely-be-bigger-if-you-have-compressible-values-or-keys-rdbcompression-yes"><a href="#Compress-string-objects-using-LZF-when-dump-rdb-databases-For-default-that’s-set-to-‘yes’-as-it’s-almost-always-a-win-If-you-want-to-save-some-CPU-in-the-saving-child-set-it-to-‘no’-but-the-dataset-will-likely-be-bigger-if-you-have-compressible-values-or-keys-rdbcompression-yes" class="headerlink" title="Compress string objects using LZF when dump .rdb databases?# For default that’s set to ‘yes’ as it’s almost always a win.# If you want to save some CPU in the saving child set it to ‘no’ but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes"></a>Compress string objects using LZF when dump .rdb databases?# For default that’s set to ‘yes’ as it’s almost always a win.# If you want to save some CPU in the saving child set it to ‘no’ but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;rdbcompression yes&#96; 是否压缩 rdb文件</span><br><span class="line"></span><br><span class="line">默认压缩 压缩会消耗cpu资源</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Since-version-5-of-RDB-a-CRC64-checksum-is-placed-at-the-end-of-the-file-This-makes-the-format-more-resistant-to-corruption-but-there-is-a-performance-hit-to-pay-around-10-when-saving-and-loading-RDB-files，-so-you-can-disable-it-for-maximum-performances-RDB-files-created-with-checksum-disabled-have-a-checksum-of-zero-that-will-tell-the-loading-code-to-skip-the-check-rdbchecksum-yes"><a href="#Since-version-5-of-RDB-a-CRC64-checksum-is-placed-at-the-end-of-the-file-This-makes-the-format-more-resistant-to-corruption-but-there-is-a-performance-hit-to-pay-around-10-when-saving-and-loading-RDB-files，-so-you-can-disable-it-for-maximum-performances-RDB-files-created-with-checksum-disabled-have-a-checksum-of-zero-that-will-tell-the-loading-code-to-skip-the-check-rdbchecksum-yes" class="headerlink" title="Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files， so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes"></a>Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files， so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;rdbchecksum yes&#96; 保存 rdb 文件时进行错误的校验</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="The-working-directory-The-DB-will-be-written-inside-this-directory，-with-the-filename-specified-above-using-the-‘dbfilename’-configuration-directive-The-Append-Only-File-will-also-be-created-inside-this-directory-Note-that-you-must-specify-a-directory-here，-not-a-file-name-dir-www-server-redis"><a href="#The-working-directory-The-DB-will-be-written-inside-this-directory，-with-the-filename-specified-above-using-the-‘dbfilename’-configuration-directive-The-Append-Only-File-will-also-be-created-inside-this-directory-Note-that-you-must-specify-a-directory-here，-not-a-file-name-dir-www-server-redis" class="headerlink" title="The working directory.## The DB will be written inside this directory， with the filename specified# above using the ‘dbfilename’ configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here， not a file name.dir /www/server/redis/"></a>The working directory.## The DB will be written inside this directory， with the filename specified# above using the ‘dbfilename’ configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here， not a file name.dir /www/server/redis/</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;rdb&#96; 文件保存的目录</span><br><span class="line"></span><br><span class="line">#### 复制 REPLICATION</span><br><span class="line"></span><br><span class="line">#### 安全 SECURITY</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Require-clients-to-issue-AUTH-before-processing-any-other-commands-This-might-be-useful-in-environments-in-which-you-do-not-trust-others-with-access-to-the-host-running-redis-server-This-should-stay-commented-out-for-backward-compatibility-and-because-most-people-do-not-need-auth-e-g-they-run-their-own-servers-Warning：-since-Redis-is-pretty-fast-an-outside-user-can-try-up-to-150k-passwords-per-second-against-a-good-box-This-means-that-you-should-use-a-very-strong-password-otherwise-it-will-be-very-easy-to-break-requirepass-foobared"><a href="#Require-clients-to-issue-AUTH-before-processing-any-other-commands-This-might-be-useful-in-environments-in-which-you-do-not-trust-others-with-access-to-the-host-running-redis-server-This-should-stay-commented-out-for-backward-compatibility-and-because-most-people-do-not-need-auth-e-g-they-run-their-own-servers-Warning：-since-Redis-is-pretty-fast-an-outside-user-can-try-up-to-150k-passwords-per-second-against-a-good-box-This-means-that-you-should-use-a-very-strong-password-otherwise-it-will-be-very-easy-to-break-requirepass-foobared" class="headerlink" title="Require clients to issue AUTH  before processing any other# commands.  This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning： since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared"></a>Require clients to issue AUTH <PASSWORD> before processing any other# commands.  This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning： since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared</PASSWORD></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;requirepass xxxxx&#96; 设置redis 登录密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#要求客户端在处理任何其他密码之前发出AUTH#命令。这在您不信任的环境中可能很有用#其他可以访问运行redis-server的主机。#这个应该被注释掉，以便向后兼容，因为大多数#人们不需要认证(例如，他们运行自己的服务器)#警告：由于Redis是相当快的外部用户可以尝试# 150k密码每秒对一个好的盒子。这意味着你应该这么做#使用一个非常强的密码，否则它会很容易被破解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 限制 CLIENTS</span><br><span class="line"></span><br><span class="line">&#96;maxclients 10000&#96; 默认有 1w 个用户可以同时连接redis 服务器</span><br><span class="line"></span><br><span class="line">&#96;maxmemory &lt;bytes&gt;&#96; redis 配置最大的内存容量</span><br><span class="line"></span><br><span class="line">&#96;maxmemory-policy noeviction&#96; 内存到达上限的处理策略 6种</span><br><span class="line"></span><br><span class="line">**1、volatile-lru：**只对设置了过期时间的key进行LRU（默认值）</span><br><span class="line"></span><br><span class="line">**2、allkeys-lru ：** 删除lru算法的key</span><br><span class="line"></span><br><span class="line">**3、volatile-random：**随机删除即将过期key</span><br><span class="line"></span><br><span class="line">**4、allkeys-random：**随机删除</span><br><span class="line"></span><br><span class="line">**5、volatile-ttl ：** 删除即将过期的</span><br><span class="line"></span><br><span class="line">**6、noeviction ：** 永不过期，返回错误</span><br><span class="line"></span><br><span class="line">#### aof配置 APPEND ONLY MODE</span><br><span class="line"></span><br><span class="line">##### 基本配置</span><br><span class="line"></span><br><span class="line">&#96;appendonly no&#96; 默认不开启 默认使用rdb持久化方式</span><br><span class="line"></span><br><span class="line">&#96;appendfilename &quot;appendonly.aof&quot;&#96; 持久化文件的名字</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="appendfsync-always-每修改一个key都会执行-sync，消耗性能appendfsync-everysec-每一秒执行一次-sync，可能会丢失这1s的数据-appendfsync-no-不执行-sync，这个时候操作系统会自己同步数据速度是最快的"><a href="#appendfsync-always-每修改一个key都会执行-sync，消耗性能appendfsync-everysec-每一秒执行一次-sync，可能会丢失这1s的数据-appendfsync-no-不执行-sync，这个时候操作系统会自己同步数据速度是最快的" class="headerlink" title="appendfsync always    // 每修改一个key都会执行 sync，消耗性能appendfsync everysec    // 每一秒执行一次 sync，可能会丢失这1s的数据# appendfsync no        // 不执行 sync，这个时候操作系统会自己同步数据速度是最快的"></a>appendfsync always    // 每修改一个key都会执行 sync，消耗性能appendfsync everysec    // 每一秒执行一次 sync，可能会丢失这1s的数据# appendfsync no        // 不执行 sync，这个时候操作系统会自己同步数据速度是最快的</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 详细配置</span><br><span class="line"></span><br><span class="line">## Redis持久化</span><br><span class="line"></span><br><span class="line">因为Redis是内存数据库，如果不把数据保存到磁盘中，那么如果机器出现断电等，数据就会丢失，</span><br><span class="line"></span><br><span class="line">所以Redis提供了持久化功能</span><br><span class="line"></span><br><span class="line">#### RDB</span><br><span class="line"></span><br><span class="line">RDB (Redis DataBase)</span><br><span class="line"></span><br><span class="line">##### 什么是RDB</span><br><span class="line"></span><br><span class="line">![image-20210420173941820](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420173941.png)</span><br><span class="line"></span><br><span class="line">就是在指定时间里把内存的数据存储到磁盘中</span><br><span class="line"></span><br><span class="line">Rdb 默认保存的文件叫做 &#96;dump.rdb&#96;</span><br><span class="line"></span><br><span class="line">![image-20210420174644255](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420174644.png)</span><br><span class="line"></span><br><span class="line">##### 触发机制</span><br><span class="line"></span><br><span class="line">![image-20210420175238907](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210420175239.png)</span><br><span class="line"></span><br><span class="line">1. save 的规则满足的情况下，会自动触发rdb规则</span><br><span class="line">2. 执行flushdb 命令，也会触发rdb文件规则</span><br><span class="line">3. 退出Redis ，也会产生rdb文件</span><br><span class="line"></span><br><span class="line">备份就会生成一个 dump.rdb文件</span><br><span class="line"></span><br><span class="line">##### 如何回复rdb文件</span><br><span class="line"></span><br><span class="line">1. 只需要将rdb文件放到Redis启动目录下就可以，Redis启动的时候自动检查&#96;dump.rdb&#96;回复其数据</span><br><span class="line">2. 可以用 &#96;config get dir&#96; 查询我们需要将文件放在那个目录下</span><br><span class="line"></span><br><span class="line">##### 优点</span><br><span class="line"></span><br><span class="line">适合大规模数据恢复</span><br><span class="line"></span><br><span class="line">对数据的完成性数据不高可以使用</span><br><span class="line"></span><br><span class="line">##### 缺点</span><br><span class="line"></span><br><span class="line">需要一定的时间间隔进行操作 ，如果在最后一次操作的时候当机了 那么最后修改的数据就没了</span><br><span class="line"></span><br><span class="line">fork 一条进程的时候会占用一定的内存空间</span><br><span class="line"></span><br><span class="line">#### AOF</span><br><span class="line"></span><br><span class="line">AOF (Append Only File)</span><br><span class="line"></span><br><span class="line">##### Aof是什么</span><br><span class="line"></span><br><span class="line">将我们的所有命令记录下来，恢复的时候就把这个文件全部再执行一遍</span><br><span class="line"></span><br><span class="line">![AOf](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210421201057.png)</span><br><span class="line"></span><br><span class="line">以日志的形式记录每一个写的操作，将Redis执行过程中的所有命令指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis启动之初会读取文件重新构建数据</span><br><span class="line"></span><br><span class="line">aof 保存的文件是 &#96;appendonly.aof&#96;</span><br><span class="line"></span><br><span class="line">![image-20210422090840407](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210422090847.png)</span><br><span class="line"></span><br><span class="line">默认是没有开启的 我们需要的话需要手动开启 把 &#96;appendonly no&#96; 改为 &#96;appendonly yes&#96;</span><br><span class="line"></span><br><span class="line">如果Aof文件受损了Redis启动不起来 我们可以通过 &#96;redis-check-aof --fix&#96; 来修复aof文件</span><br><span class="line"></span><br><span class="line">![image-20210422091808551](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210422091808.png)</span><br><span class="line"></span><br><span class="line">##### 优点</span><br><span class="line"></span><br><span class="line">1. 每一次修改都同步，文件的完整性会更加好</span><br><span class="line">2. 每秒同步一次，可能会丢失一秒的数据</span><br><span class="line">3. 从来不同步，效率最高</span><br><span class="line"></span><br><span class="line">##### 缺点</span><br><span class="line"></span><br><span class="line">1. 相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</span><br><span class="line">2. aof 运行效率也要比rdb慢，所以Redis默认的配置就是rdb持久化</span><br><span class="line"></span><br><span class="line">## Redis发布与订阅</span><br><span class="line"></span><br><span class="line">Redis 发布订阅（pub&#x2F;sub）是一种&#x3D;&#x3D;消息通信模式&#x3D;&#x3D;：发送者（pub）发送消息，订阅者（sub）接收消息 ——— &gt; &#x3D;&#x3D;微信 、微博的 关注系统&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Redis 客户端可以订阅任意数量的频道</span><br><span class="line"></span><br><span class="line">订阅&#x2F;发布消息图：</span><br><span class="line"></span><br><span class="line">- 消息发布者</span><br><span class="line">- 频道</span><br><span class="line">- 消息订阅者</span><br><span class="line"></span><br><span class="line">![image-20210423090614975](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210423090622.png)</span><br><span class="line"></span><br><span class="line">下图是频道 channel1 ， 以及订阅这个频道的三个客户端 ——- cilent2，cilent5 和 cilent1 之间的关系</span><br><span class="line"></span><br><span class="line">![image-20210423091450391](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210423091450.png)</span><br><span class="line"></span><br><span class="line">当有消息通过Publish 命令发送给频道 channel1 时，这个消息就会被它发送给订阅它的三个客户端</span><br><span class="line"></span><br><span class="line">![image-20210423091506037](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210423091506.png)</span><br><span class="line"></span><br><span class="line">### 命令</span><br><span class="line"></span><br><span class="line">redis 发布订阅常用命令：</span><br><span class="line"></span><br><span class="line">| 序号 | 命令及描述                                                   |</span><br><span class="line">| :--- | :----------------------------------------------------------- |</span><br><span class="line">| 1    | PSUBSCRIBE pattern [[pattern …\]](https:&#x2F;&#x2F;www.runoob.com&#x2F;redis&#x2F;pub-sub-psubscribe.html) 订阅一个或多个符合给定模式的频道。 |</span><br><span class="line">| 2    | [PUBSUB subcommand [argument [argument …\]]](https:&#x2F;&#x2F;www.runoob.com&#x2F;redis&#x2F;pub-sub-pubsub.html) 查看订阅与发布系统状态。 |</span><br><span class="line">| 3    | [PUBLISH channel message](https:&#x2F;&#x2F;www.runoob.com&#x2F;redis&#x2F;pub-sub-publish.html) 将信息发送到指定的频道。 |</span><br><span class="line">| 4    | [PUNSUBSCRIBE [pattern [pattern …\]]](https:&#x2F;&#x2F;www.runoob.com&#x2F;redis&#x2F;pub-sub-punsubscribe.html) 退订所有给定模式的频道。 |</span><br><span class="line">| 5    | SUBSCRIBE channel [channel …\]](https:&#x2F;&#x2F;www.runoob.com&#x2F;redis&#x2F;pub-sub-subscribe.html) 订阅给定的一个或多个频道的信息。 |</span><br><span class="line">| 6    | [UNSUBSCRIBE [channel [channel …\]]](https:&#x2F;&#x2F;www.runoob.com&#x2F;redis&#x2F;pub-sub-unsubscribe.html) 指退订给定的频道。 |</span><br><span class="line"></span><br><span class="line">订阅信息：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>0.0.1：6379&gt; subscribe king     // 订阅一个频道Reading messages… (press Ctrl-C to quit)1) “subscribe”2) “king”3) (integer) 1    // 等待推送的信息1) “message”   // 消息2) “king”      // 来自于那个频道3) “hello，yss”  // 来自哪个频道的内容1) “message”2) “king”3) “\xe6\x88\x91\xe7\x88\xb1\xe4\xbd\xa0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推送信息：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>0.0.1：6379&gt; publish king “hello，yss”  // 发布信息到指定的频道(integer) 1127.0.0.1：6379&gt; publish king “我爱你”(integer) 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Redis主从复制</span><br><span class="line"></span><br><span class="line">### 概念</span><br><span class="line"></span><br><span class="line">一般来说，要将 Redis用于工程项目中，只使用一台 Redist是万万不能的，原因如下：</span><br><span class="line"></span><br><span class="line">1、从结构上，单个 Redist服务器会发生单点故障，井且一台服务器需要处理所有的请求负載，压力较大</span><br><span class="line"></span><br><span class="line">2、从容量上，单个 Redis服务器内存容量有限就算一台 Redis服务器内存容量为266，也不能将所有内存用作 Redis?存储内存一般来说，单台 Redist最大使用内存不应该超过206</span><br><span class="line"></span><br><span class="line">电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</span><br><span class="line">对于这种场景，我们可以使如下这种架构主从复制，息指将一台Reds3服的数据，复制他的Reds眼努，前者称为主节点 master&#x2F;leade，后者称为从节点( slave&#x2F; follower);数据的复制是单向的，只能由主节点到从节点。 Master以写为主，Save以读为主。</span><br><span class="line"></span><br><span class="line">认情况下，每台 Redish服务器都是主节点：且ー个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点</span><br><span class="line">主从复制的作用主要包括：</span><br><span class="line"></span><br><span class="line">1. 数据元余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</span><br><span class="line">2. 故障恢复：当主节点出现可题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</span><br><span class="line">3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写 Redisa效据时应用连接主节点，读Reds数据时应用连接从节点)，分担服务器负载;尤具是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis服务器的并发量</span><br><span class="line">4. 高可用(集群)基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Reds高可用的基础</span><br><span class="line"></span><br><span class="line">### 环境配置</span><br><span class="line"></span><br><span class="line">只配置从库，不配置主库！</span><br><span class="line"></span><br><span class="line">**查看当前库的信息**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>0.0.1：6379&gt; info replication# Replicationrole：master   // 角色connected_slaves：0  // 连接的丛机 master_failover_state：no-failovermaster_replid：c52bb664e09e9e76e9c995fdd15215578e38250fmaster_replid2：0000000000000000000000000000000000000000master_repl_offset：0second_repl_offset：-1repl_backlog_active：0repl_backlog_size：1048576repl_backlog_first_byte_offset：0repl_backlog_histlen：0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210424193553158](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210424193600.png)</span><br><span class="line"></span><br><span class="line">复制3个Redis.conf</span><br><span class="line"></span><br><span class="line">然后修改配置文件：</span><br><span class="line"></span><br><span class="line">1. 端口号</span><br><span class="line">2. .pid 名字</span><br><span class="line">3. log 文件名字</span><br><span class="line">4. dump.rdb 名字</span><br><span class="line"></span><br><span class="line">### 配置成功</span><br><span class="line"></span><br><span class="line">启动3个redis</span><br><span class="line"></span><br><span class="line">![image-20210427152706030](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427152713.png)</span><br><span class="line"></span><br><span class="line">### 一主二从</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;默认情况Redis每一个服务都是主节点&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">一般只配置从机</span><br><span class="line"></span><br><span class="line">一主 （6310）二从 （6320，6330）</span><br><span class="line"></span><br><span class="line">查看Redis当前库信息</span><br><span class="line"></span><br><span class="line">&#96;6310&#96;的信息</span><br><span class="line"></span><br><span class="line">![image-20210427153212906](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427153213.png)</span><br><span class="line"></span><br><span class="line">&#96;6320&#96;的信息</span><br><span class="line"></span><br><span class="line">![image-20210427153233963](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427153234.png)</span><br><span class="line"></span><br><span class="line">&#96;6330&#96;的信息</span><br><span class="line"></span><br><span class="line">![image-20210427153312486](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427153312.png)</span><br><span class="line"></span><br><span class="line">#### 配置</span><br><span class="line"></span><br><span class="line">命令&#96;slaveof 127.0.0.1 6310&#96;</span><br><span class="line"></span><br><span class="line">给 &#96;6320&#96; 认 &#96;6310&#96; 是老大</span><br><span class="line"></span><br><span class="line">&#96;6320&#96;的信息</span><br><span class="line"></span><br><span class="line">![image-20210427153811589](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427153811.png)</span><br><span class="line"></span><br><span class="line">同样给 &#96;6330&#96; 配置一下</span><br><span class="line"></span><br><span class="line">&#96;6310&#96;的信息</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>0.0.1:6310&gt; info replication# Replicationrole:master     // 主机标识connected_slaves:1   // 他有一个从机slave0:ip=127.0.0.1  // 从机地址,port=6320  // 从机端口,state=online // 从机状态 ,offset=252,lag=1master_failover_state:no-failovermaster_replid:1c382c2d63dcacaabab6ce01942c24c1b1d3fbb1master_replid2:0000000000000000000000000000000000000000master_repl_offset:252second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:252</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2个都配置完成</span><br><span class="line"></span><br><span class="line">![image-20210427154330727](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427154330.png)</span><br><span class="line"></span><br><span class="line">### 细节</span><br><span class="line"></span><br><span class="line">主机可以写，从机不可以写只能读！主机中的所有数据都会被从机保存</span><br><span class="line"></span><br><span class="line">主机可以读写 ：</span><br><span class="line"></span><br><span class="line">![image-20210427154957290](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427154957.png)</span><br><span class="line"></span><br><span class="line">从机只能读不能写不然会报错：</span><br><span class="line"></span><br><span class="line">![image-20210427155036738](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427155036.png)</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;测试&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1、主机宕机了 从机状态</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>0.0.1:6310&gt; SHUTDOWNnot connected&gt; exit[root@King bin]# redis-cli -p 6310Could not connect to Redis at 127.0.0.1:6310: Connection refusednot connected&gt; pingCould not connect to Redis at 127.0.0.1:6310: Connection refused</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">主机关闭</span><br><span class="line"></span><br><span class="line">![image-20210427160524806](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427160524.png)</span><br><span class="line"></span><br><span class="line">![image-20210427160413157](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427160413.png)</span><br><span class="line"></span><br><span class="line">主机宕机不会影响从机的读取操作</span><br><span class="line"></span><br><span class="line">2、主机从新工作</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[root@King bin]# redis-server KingConfig/redis-10.conf[root@King bin]# redis-cli -p 6310127.0.0.1:6310&gt; pingPONG127.0.0.1:6310&gt; set k2 v2OK127.0.0.1:6310&gt; get k2”v2”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从机状态</span><br><span class="line"></span><br><span class="line">![image-20210427160810556](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427160810.png)</span><br><span class="line"></span><br><span class="line">也可以查询值</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>0.0.1:6320&gt; get k2”v2”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试从机断开 ：如果从机是使用命令连接的主机 那么从机断开之后 重新连接 他就会变为自己的主机，这样是取不到主机更新数据，但是可以取到以前的数据，我们重新让它成为从机 那么他还是可以读取到数据</span><br><span class="line"></span><br><span class="line">### 复制原理</span><br><span class="line"></span><br><span class="line">Slave启动成功连接到 master 后会发送一个sync命令</span><br><span class="line"></span><br><span class="line">Master接到命令,启动后台的存盘进程,同时收集所有接收到的用于修改数据集命令,在后台进程执行完毕之后, master将传送整个数据文件到 slave,井完成一次完全同步</span><br><span class="line"></span><br><span class="line">全量复制：而 slave服务在接收到数据库文件数据后,将其存盘井加载到内存中</span><br><span class="line"></span><br><span class="line">增量复制：Master继续将新的所有收集到的修改命令依次传给 slave,完成同步</span><br><span class="line"></span><br><span class="line">但是只要是重新连接 master,一次完全同步(全量复制)将被自动执行</span><br><span class="line"></span><br><span class="line">### 主机宕机</span><br><span class="line"></span><br><span class="line">如果主机宕机了，从机想要变成主机 我们可以通过命令 &#96;slaveof no noe&#96; 让自己变成主机！其他节点就可以手动连接，这个时候主机连接了 还想要 这个主机当老大 那么我们需要手动配置</span><br><span class="line"></span><br><span class="line">## 哨兵模式</span><br><span class="line"></span><br><span class="line">**主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。**这不是一种推荐的方式，更多时候，我们优先考虑**哨兵模式**。</span><br><span class="line"></span><br><span class="line">### 哨兵模式概述</span><br><span class="line"></span><br><span class="line">哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**</span><br><span class="line"></span><br><span class="line">![1](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210428112107.webp)</span><br><span class="line"></span><br><span class="line">### Redis哨兵</span><br><span class="line"></span><br><span class="line">这里的哨兵有两个作用</span><br><span class="line"></span><br><span class="line">- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</span><br><span class="line">- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。</span><br><span class="line"></span><br><span class="line">然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</span><br><span class="line"></span><br><span class="line">用文字描述一下**故障切换（failover）**的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。</span><br><span class="line"></span><br><span class="line">### Redis配置哨兵模式</span><br><span class="line"></span><br><span class="line">配置3个哨兵和1主2从的Redis服务器来演示这个过程。</span><br><span class="line"></span><br><span class="line">| 服务类型 | 是否是主服务器 | IP地址         | 端口  |</span><br><span class="line">| -------- | -------------- | -------------- | ----- |</span><br><span class="line">| Redis    | 是             | 192.168.11.128 | 6379  |</span><br><span class="line">| Redis    | 否             | 192.168.11.129 | 6379  |</span><br><span class="line">| Redis    | 否             | 192.168.11.130 | 6379  |</span><br><span class="line">| Sentinel | -              | 192.168.11.128 | 26379 |</span><br><span class="line">| Sentinel | -              | 192.168.11.129 | 26379 |</span><br><span class="line">| Sentinel | -              | 192.168.11.130 | 26379 |</span><br><span class="line"></span><br><span class="line">![2](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210428112219.webp)</span><br><span class="line"></span><br><span class="line">多哨兵监控Redis</span><br><span class="line"></span><br><span class="line">首先配置Redis的主从服务器，修改redis.conf文件如下</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="使得Redis服务器可以跨网络访问bind-0-0-0-0-设置密码requirepass-“123456”-指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置slaveof-192-168-11-128-6379-主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置masterauth-123456"><a href="#使得Redis服务器可以跨网络访问bind-0-0-0-0-设置密码requirepass-“123456”-指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置slaveof-192-168-11-128-6379-主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置masterauth-123456" class="headerlink" title="使得Redis服务器可以跨网络访问bind 0.0.0.0# 设置密码requirepass “123456”# 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置slaveof 192.168.11.128 6379# 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置masterauth 123456"></a>使得Redis服务器可以跨网络访问bind 0.0.0.0# 设置密码requirepass “123456”# 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置slaveof 192.168.11.128 6379# 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置masterauth 123456</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述内容主要是配置Redis服务器，从服务器比主服务器多一个slaveof的配置和密码。</span><br><span class="line"></span><br><span class="line">配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="禁止保护模式protected-mode-no-配置监听的主服务器，这里sentinel-monitor代表监控，mymaster代表服务器的名称，可以自定义，192-168-11-128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。sentinel-monitor-mymaster-192-168-11-128-6379-2-sentinel-author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码-sentinel-auth-pass-sentinel-auth-pass-mymaster-123456"><a href="#禁止保护模式protected-mode-no-配置监听的主服务器，这里sentinel-monitor代表监控，mymaster代表服务器的名称，可以自定义，192-168-11-128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。sentinel-monitor-mymaster-192-168-11-128-6379-2-sentinel-author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码-sentinel-auth-pass-sentinel-auth-pass-mymaster-123456" class="headerlink" title="禁止保护模式protected-mode no# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。sentinel monitor mymaster 192.168.11.128 6379 2# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码# sentinel auth-pass  sentinel auth-pass mymaster 123456"></a>禁止保护模式protected-mode no# 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。sentinel monitor mymaster 192.168.11.128 6379 2# sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码# sentinel auth-pass <master-name> <password>sentinel auth-pass mymaster 123456</password></master-name></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述关闭了保护模式，便于测试。</span><br><span class="line"></span><br><span class="line">有了上述的修改，我们可以进入Redis的安装目录的src目录，通过下面的命令启动服务器和哨兵</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="启动Redis服务器进程-redis-server-redis-conf-启动哨兵进程-redis-sentinel-sentinel-conf"><a href="#启动Redis服务器进程-redis-server-redis-conf-启动哨兵进程-redis-sentinel-sentinel-conf" class="headerlink" title="启动Redis服务器进程./redis-server ../redis.conf# 启动哨兵进程./redis-sentinel ../sentinel.conf"></a>启动Redis服务器进程./redis-server ../redis.conf# 启动哨兵进程./redis-sentinel ../sentinel.conf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意启动的顺序。**首先是主机（192.168.11.128）的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程。**</span><br><span class="line"></span><br><span class="line">### 哨兵模式的其他配置项</span><br><span class="line"></span><br><span class="line">| 配置项                           | 参数类型                     | 作用                                                         |</span><br><span class="line">| -------------------------------- | ---------------------------- | ------------------------------------------------------------ |</span><br><span class="line">| port                             | 整数                         | 启动哨兵进程端口                                             |</span><br><span class="line">| dir                              | 文件夹目录                   | 哨兵进程服务临时文件夹，默认为&#x2F;tmp，要保证有可写入的权限     |</span><br><span class="line">| sentinel down-after-milliseconds | &lt;服务名称&gt;&lt;毫秒数（整数）&gt;   | 指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒） |</span><br><span class="line">| sentinel parallel-syncs          | &lt;服务名称&gt;&lt;服务器数（整数）&gt; | 指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高 |</span><br><span class="line">| sentinel failover-timeout        | &lt;服务名称&gt;&lt;毫秒数（整数）&gt;   | 指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟 |</span><br><span class="line">| sentinel notification-script     | &lt;服务名称&gt;&lt;脚本路径&gt;         | 指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用 |</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</span><br><span class="line"></span><br><span class="line">### 哨兵配置</span><br><span class="line"></span><br><span class="line">配置哨兵配置文件 &#96;sentinel.conf&#96;</span><br><span class="line"></span><br><span class="line">![image-20210427221721022](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427221728.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sentinel monitor 被监控的名字自定义 ip地址 端口号 1<br>sentinel monitor myredis 127.0.0.1 6310 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">后面这个1代表 如果主机宕机了 slave 投票看让谁接替成为主机，票数最多的，就会成为主机</span><br><span class="line"></span><br><span class="line">用 &#96;redis-sentinel&#96; 服务来启动 哨兵</span><br><span class="line"></span><br><span class="line">![image-20210427222948307](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427222948.png)</span><br><span class="line"></span><br><span class="line">这个时候如果主机宕机了</span><br><span class="line"></span><br><span class="line">![image-20210427223236066](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210527095042.png)</span><br><span class="line"></span><br><span class="line">哨兵就会去检测 主机是否还有呼吸 如果检查没有了 那么他就是从从机里面选一个来作为主机</span><br><span class="line"></span><br><span class="line">选举 6320 来做为主机</span><br><span class="line"></span><br><span class="line">![image-20210427223441603](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427223441.png)</span><br><span class="line"></span><br><span class="line">如果 6310 回来 那么 他就会作为 现任老大的从机</span><br><span class="line"></span><br><span class="line">![image-20210427223921295](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427223921.png)</span><br><span class="line"></span><br><span class="line">&#96;6320&#96; 主机</span><br><span class="line"></span><br><span class="line">![image-20210427224011068](https:&#x2F;&#x2F;gitee.com&#x2F;Apollo_king&#x2F;myblog&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210427224011.png)</span><br><span class="line"></span><br><span class="line">### 哨兵集群配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Example-sentinel-conf-port-哨兵的默认端口-默认是-26379-port-8001-守护进程模式daemonize-yes-指明日志文件名logfile-“-sentinel1-log”-工作路径，sentinel一般指定-tmp比较简单dir-哨兵监控这个master，在至少quorum个哨兵实例都认为master-down后把master标记为odown-（objective-down客观down；相对应的存在sdown，subjective-down，主观down）状态。-slaves是自动发现，所以你没必要明确指定slaves。sentinel-monitor-MyMaster-127-0-0-1-7001-1-master或slave多长时间（默认30秒）不能使用后标记为s-down状态。sentinel-down-after-milliseconds-MyMaster-1500-若sentinel在该配置值内未能完成failover操作（即故障时master-slave自动切换），则认为本次failover失败。sentinel-failover-timeout-TestMaster-10000-设置master和slaves验证密码sentinel-auth-pass-TestMaster-testmaster123sentinel-config-epoch-TestMaster-15-除了当前哨兵-还有哪些在监控这个master的哨兵sentinel-known-sentinel-TestMaster-127-0-0-1-8002-0aca3a57038e2907c8a07be2b3c0d15171e44da5sentinel-known-sentinel-TestMaster-127-0-0-1-8003-ac1ef015411583d4b9f3d81cee830060b2f29862"><a href="#Example-sentinel-conf-port-哨兵的默认端口-默认是-26379-port-8001-守护进程模式daemonize-yes-指明日志文件名logfile-“-sentinel1-log”-工作路径，sentinel一般指定-tmp比较简单dir-哨兵监控这个master，在至少quorum个哨兵实例都认为master-down后把master标记为odown-（objective-down客观down；相对应的存在sdown，subjective-down，主观down）状态。-slaves是自动发现，所以你没必要明确指定slaves。sentinel-monitor-MyMaster-127-0-0-1-7001-1-master或slave多长时间（默认30秒）不能使用后标记为s-down状态。sentinel-down-after-milliseconds-MyMaster-1500-若sentinel在该配置值内未能完成failover操作（即故障时master-slave自动切换），则认为本次failover失败。sentinel-failover-timeout-TestMaster-10000-设置master和slaves验证密码sentinel-auth-pass-TestMaster-testmaster123sentinel-config-epoch-TestMaster-15-除了当前哨兵-还有哪些在监控这个master的哨兵sentinel-known-sentinel-TestMaster-127-0-0-1-8002-0aca3a57038e2907c8a07be2b3c0d15171e44da5sentinel-known-sentinel-TestMaster-127-0-0-1-8003-ac1ef015411583d4b9f3d81cee830060b2f29862" class="headerlink" title="Example sentinel.conf# port  哨兵的默认端口 默认是 26379 port 8001# 守护进程模式daemonize yes# 指明日志文件名logfile “./sentinel1.log”# 工作路径，sentinel一般指定/tmp比较简单dir ./# 哨兵监控这个master，在至少quorum个哨兵实例都认为master down后把master标记为odown# （objective down客观down；相对应的存在sdown，subjective down，主观down）状态。# slaves是自动发现，所以你没必要明确指定slaves。sentinel monitor MyMaster 127.0.0.1 7001 1# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。sentinel down-after-milliseconds MyMaster 1500# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。sentinel failover-timeout TestMaster 10000# 设置master和slaves验证密码sentinel auth-pass TestMaster testmaster123sentinel config-epoch TestMaster 15#除了当前哨兵, 还有哪些在监控这个master的哨兵sentinel known-sentinel TestMaster 127.0.0.1 8002 0aca3a57038e2907c8a07be2b3c0d15171e44da5sentinel known-sentinel TestMaster 127.0.0.1 8003 ac1ef015411583d4b9f3d81cee830060b2f29862"></a>Example sentinel.conf# port <sentinel-port> 哨兵的默认端口 默认是 26379 port 8001# 守护进程模式daemonize yes# 指明日志文件名logfile “./sentinel1.log”# 工作路径，sentinel一般指定/tmp比较简单dir ./# 哨兵监控这个master，在至少quorum个哨兵实例都认为master down后把master标记为odown# （objective down客观down；相对应的存在sdown，subjective down，主观down）状态。# slaves是自动发现，所以你没必要明确指定slaves。sentinel monitor MyMaster 127.0.0.1 7001 1# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。sentinel down-after-milliseconds MyMaster 1500# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。sentinel failover-timeout TestMaster 10000# 设置master和slaves验证密码sentinel auth-pass TestMaster testmaster123sentinel config-epoch TestMaster 15#除了当前哨兵, 还有哪些在监控这个master的哨兵sentinel known-sentinel TestMaster 127.0.0.1 8002 0aca3a57038e2907c8a07be2b3c0d15171e44da5sentinel known-sentinel TestMaster 127.0.0.1 8003 ac1ef015411583d4b9f3d81cee830060b2f29862</sentinel-port></h1><pre><code></code></pre></li></ol><h2 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h2><h3 id="缓存穿透-查不到"><a href="#缓存穿透-查不到" class="headerlink" title="缓存穿透 (查不到)"></a>缓存穿透 (查不到)</h3><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/20210428090700.png" alt="img"></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。</p><p>可以先有一亿个二进制比特，然后网警用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指纹（f1, f2, …, f8）。接下来用一个随机数产生器 G 把这八个信息指纹映射到 1 到1亿中的八个自然数 g1, g2, …,g8。最后把这八个位置的二进制全部设置为一。过程如下：</p><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/20210428112232.jpeg" alt="3"></p><p>有一天网警查到了一个可疑的网站，想判断一下是否是XX网站，首先将可疑网站通过哈希映射到1亿个比特数组上的8个点。如果8个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。</p><p>那这个布隆过滤器是如何解决redis中的缓存穿透呢？很简单首先也是对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。</p><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/20210428112356.jpeg" alt="1"></p><p>这个形式很简单。</p><h5 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a><strong>缓存空对象</strong></h5><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/20210428112403.jpeg" alt="2"></p><p>但是这种方法会存在两个问题：</p><p>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿-查询量太大，缓存过期）"><a href="#缓存击穿-查询量太大，缓存过期）" class="headerlink" title="缓存击穿 (查询量太大，缓存过期）"></a>缓存击穿 (查询量太大，缓存过期）</h3><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol><li>设置热点数据永远不过期</li><li>接口限流与熔断，降级</li></ol><p>重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。</p><ol><li>布隆过滤器</li></ol><p>bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小</p><ol><li>加互斥锁，互斥锁参考代码如下：</li></ol><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/20210428112411.png" alt="3"></p><p>说明：</p><p> 1）缓存中有数据，直接走上述代码13行后就返回结果了</p><p> 2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。</p><p> 3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="https://gitee.com/Apollo_king/myblog/raw/master/img/20210428112417.jpeg" alt="4"></p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><p><strong>（1）redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p><p><strong>（2）限流降级</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>（3）数据预热</strong></p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人事</title>
      <link href="2021/05/18/%E4%BA%BA%E4%BA%8B/"/>
      <url>2021/05/18/%E4%BA%BA%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-做一下自我介绍。"><a href="#1-做一下自我介绍。" class="headerlink" title="1.做一下自我介绍。"></a>1.做一下自我介绍。</h3><p>某某总您好，我叫小🐏，来自湖北武汉，今天来到贵公司面试，以前是在某某某公司坐后端开发</p><h3 id="2-如何评价你自己？"><a href="#2-如何评价你自己？" class="headerlink" title="2.如何评价你自己？"></a>2.如何评价你自己？</h3><p>就是我有一个成为詹姆斯·高斯林的梦想，但是我没有人家那个脑子，也没有人家那个能力，也没有那个学历，所以呢。<br>我只能出此下策。来到你们公司，没办法嘛，我要生活嘛，我就这么个人儿。</p><p><strong>才不足道，貌不足凭。智商不高，情商为零。</strong></p><p><strong>一无所长，偏是自负。爱说道理，不与人听。</strong></p><h3 id="3-如何看待出差和加班？"><a href="#3-如何看待出差和加班？" class="headerlink" title="3.如何看待出差和加班？"></a>3.如何看待出差和加班？</h3><p>出差的话，如果是工作需要，我会服从安排，认真做好工作，毕竟出差也是领导们对我的信任，还能够锻炼我自身能力</p><p>我个人非常反感加班，也拒绝加班。我也不同意把拒绝加班当成不适应社会的表现。这是新人类自我意识觉醒的征兆。<br>（<strong>我喜欢适当的加班，加班能更快的提升我的工作效率，自身能力和我的价值。</strong>）</p><h3 id="4-为什么会选择我们公司？"><a href="#4-为什么会选择我们公司？" class="headerlink" title="4.为什么会选择我们公司？"></a>4.为什么会选择我们公司？</h3><p>因为你们在招人，<br>我为啥选择你们公司你不知道嘛？？<br>牌子这么响！<br>公司这么大！<br>工资这么高！<br>待遇这么好！<br>还不用996！<br>不选择你们，我不是傻么？<br>（如果是996）<br>你们公司是996啊？不早说！下回在你们招聘广告写清楚！真耽误功夫！</p><p><strong>因为我看了贵公司的业务，与我的期望方向是很契合的。</strong></p><h3 id="5-你的期望薪资是？上一家公司的薪资构成是？"><a href="#5-你的期望薪资是？上一家公司的薪资构成是？" class="headerlink" title="5.你的期望薪资是？上一家公司的薪资构成是？"></a>5.你的期望薪资是？上一家公司的薪资构成是？</h3><p>7-8k一个月，希望公司能接受，入职之后我一定会把我毕生所学的技术运用到公司项目，给公司一个辉煌的未来，和公司携手共进，共创未来，公司就是我的第二个家…</p><p>上家公司的薪资构成底薪加绩效</p><h3 id="6-工作之余比较喜欢做什么呢？"><a href="#6-工作之余比较喜欢做什么呢？" class="headerlink" title="6.工作之余比较喜欢做什么呢？"></a>6.工作之余比较喜欢做什么呢？</h3><p>如果无聊，就会出去散散步或者是看看书。我把大冰的书，放到随时都可以看到的地方，几本书中都有提到不要</p><p>“一门心思的玩放弃，退学流浪，盲目辞职，一门心思地追求世俗意义上的成功，把朝九晚五当标准答案，乃至唯一答案 。他始终弘扬出世与入世的平衡，平行世界，多元生活”</p><p>他的文字，会让我发现生活中平淡无奇的事情，生出很多乐趣。</p><p>放假闲暇时间也会约好友，一起吃饭，运动。吃饭不在沉闷，运动也不在痛苦。</p><h3 id="7-为什么从上家公司离职？"><a href="#7-为什么从上家公司离职？" class="headerlink" title="7.为什么从上家公司离职？"></a>7.为什么从上家公司离职？</h3><p>我：你们为啥要招人，是不是之前的人干不下去了？</p><p>我：上家公司也还没离职，不是你们请我来面试的吗？</p><p><strong>上家公司新装修入驻了一年了，气味还是很大，身体受不了！！！</strong></p><h3 id="8-除了本公司外，还应聘了哪些公司？"><a href="#8-除了本公司外，还应聘了哪些公司？" class="headerlink" title="8.除了本公司外，还应聘了哪些公司？"></a>8.除了本公司外，还应聘了哪些公司？</h3><p>有拿到其他两家公司的offer，但是他们那边的业务不是很熟悉，所以再来贵公司这边看看，单看你们招聘信息上的业务我还是比较熟悉的</p><h3 id="9-你还有什么问题要问吗？"><a href="#9-你还有什么问题要问吗？" class="headerlink" title="9.你还有什么问题要问吗？"></a>9.你还有什么问题要问吗？</h3><p>公司是否有培训计划让我不断学习，为公司创造更大价值？</p><p>我的岗位在贵公司的职业发展通道是怎样的？我想参考确定未来努力的目标和方向。</p><h3 id="10-什么时候可以到岗？"><a href="#10-什么时候可以到岗？" class="headerlink" title="10.什么时候可以到岗？"></a>10.什么时候可以到岗？</h3><p>上家公司那边是一个月离职，如果这边确定Offer了，我提离职，和老板申请下，大概两三周左右，那边老板人挺好的，应该会批，我争取尽快到岗</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库面试题</title>
      <link href="2021/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p>1NF：属性不可分</p><p>2NF：非主键属性，完全依赖于主键属性</p><p>3NF：非主键属性无传递依赖</p><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ol><li>原子性：要么执行，要么不执行</li><li>隔离性：所有操作全部执行完成以前其他会话不能看到过程</li><li>一致性：事务前后，数据额一致</li><li>持久性：一旦事务提交，对数据的改变就是永久的</li></ol><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p>多个事务可能会出现以下问题：</p><ol><li>脏读：事务A读取事务B还没有提交的数据</li><li>不可重复读：数据库中得某个数据，一个事务范围内得多次查询却返回了不同的结果，这就是由于在查询过程中，数据被另一个事务修改并提交了</li><li>幻读：当事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时这两个区别在于，不可重复读重点在一行，幻读的重点，返回值的集合不一样</li></ol><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程就是一组预先编译好的SQL语句集</p><p>优点：减少重用性，减少冗余</p><p>​            减少SQL的编译次数，减少了与服务器连接交互的次数</p><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据地情况。若对并发操作不加控制就可能会读取和存储不正确地数据，破坏数据库的一致性。</p><h3 id="MySQL的两种存储引擎的区别（事务，锁级别）"><a href="#MySQL的两种存储引擎的区别（事务，锁级别）" class="headerlink" title="MySQL的两种存储引擎的区别（事务，锁级别）"></a>MySQL的两种存储引擎的区别（事务，锁级别）</h3><p>MYISAM：非事务的存储引擎，适合用于频繁查询的应用。表锁，不会出现死锁，适合小数据，小并发</p><p>INNODB：支持事务的存储引擎，合于插入和更新操作比较多的应用，设计合理的话是行锁（最大区别就在锁的级别上），适合大数据，大并发</p><h3 id="索引B-和hash索引"><a href="#索引B-和hash索引" class="headerlink" title="索引B+和hash索引"></a>索引B+和hash索引</h3><p>B+：数据有序，范围查询</p><p>Hash：hash索引，等值查询效率搞，不能排序，不能进行范围查询</p><h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><p>聚集索引：数据按索引顺序存储，中子节点存储真实的物理数据</p><p>非聚集索引：存储指向真正数据行的指针</p><h3 id="索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>索引的优缺点，什么时候使用索引，什么时候不能使用索引</h3><p>优点：索引最大的好处就是提高查询速度</p><p>缺点：更新数据时查询效率低，因为要同时更新索引</p><p>什么时候不能使用：对数据进行频繁查询就建立索引，如果是要频繁更改数据不建议使用索引</p><h3 id="InnonDB索引和MyISAM索引的区别"><a href="#InnonDB索引和MyISAM索引的区别" class="headerlink" title="InnonDB索引和MyISAM索引的区别"></a>InnonDB索引和MyISAM索引的区别</h3><ol><li>索引的区别：InnoDB的数据文件本身就是索引文件。而MYISAM得索引和数据是分开得</li><li>辅助索引的区别：InnonDB的辅助索引data域存储相应记录</li></ol><h3 id="索引的底层实现B-树为何不采用红黑树，（B树重点）"><a href="#索引的底层实现B-树为何不采用红黑树，（B树重点）" class="headerlink" title="索引的底层实现B+树为何不采用红黑树，（B树重点）"></a>索引的底层实现B+树为何不采用红黑树，（B树重点）</h3><p>树区别：</p><p>红黑树：增加，删除 ，红黑树会进行频繁的调整，来保存红黑树的性质，浪费时间</p><p>B树：也就是B-树，B树，对查询性能不稳定，查询结果的高度不一致，每个节点保存指向真实数据的指针。相比B+数每一层存储的元素更多，显得更高</p><p>B+树： B+树相比较与另外的两种树，显得更矮更宽，查询层次更浅</p><h3 id="B-树的实现"><a href="#B-树的实现" class="headerlink" title="B+树的实现"></a>B+树的实现</h3><p>一个m阶的B+树具有如下几个特征</p><ol><li>有K个子树的中间节点包含有K个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点</li><li>所有叶子节点中包含了全部元素信息，及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接</li><li>所有中间节点元素都同时存在于子节点，在子节点袁术中是最大元素</li></ol><h3 id="为什么使用B-Tree"><a href="#为什么使用B-Tree" class="headerlink" title="为什么使用B+Tree"></a>为什么使用B+Tree</h3><p>索引查找过程中就要产生磁盘I/O消耗，主要看IO次数，和磁盘存取原理有关</p><p>更具B-Terr的定义，可知检索一次最多需要访问H个节点。数据库系统的设计巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。局部性原理与磁盘预读</p><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><ol><li>选择正确的存储引擎，每个存储引擎都有利有弊</li><li>优化字段的数据类型</li><li>查询走索引</li><li>避免使用Select *</li><li>尽可能使用NOT NULL，除非有特别的原因要去使用NULL值，NULL也需要额外的空间</li><li>子查询变成left join</li><li>不必要的排序</li><li>where代替having,having 检索完所有记录，才进行过滤</li><li>避免嵌套查询</li><li>对多个字段进行等值查询时，联合索引</li></ol><h3 id="NULL是什么意思"><a href="#NULL是什么意思" class="headerlink" title="NULL是什么意思"></a>NULL是什么意思</h3><p>NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。、</p><h3 id="数据库连接池的作用"><a href="#数据库连接池的作用" class="headerlink" title="数据库连接池的作用"></a>数据库连接池的作用</h3><p>维护一定数量的连接，减少创建连接的时间</p><p> 更快的响应时间 </p><p>统一的管理</p><h3 id="有哪些锁"><a href="#有哪些锁" class="headerlink" title="有哪些锁"></a>有哪些锁</h3><p>乐观锁：自己实现，通过版本号</p><p>悲观锁：共享锁，多个事务，只能读不能写，加lock in share mode</p><p>排他锁：一个事务，只能写，for update</p><p>行锁：作用域数据行</p><p>表锁：作用于表</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础面试题</title>
      <link href="2021/05/10/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/05/10/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的生命周期分为5个阶段：新建，就绪，运行，阻塞，销毁</p><ol><li>新建：就是刚使用new方法，new出来的线程;</li><li>就绪：就是调用的线程的start()方法后，这个时候线程就处于等待CPU分配资源阶段，谁先抢到CPU资源，谁就开始执行</li><li>运行：当就绪的线程被调度并获得CPU资源时，就进入运行状态，run方法定义了线程的操作和功能</li><li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如：sleep()，wait()之后线程就处于阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify()或者notifyAll()方法。唤醒的线程不会立即执行run方法，它们要再次等待CPU分配资源进入运行状态</li><li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源</li></ol><h3 id="使线程阻塞的方法有哪些"><a href="#使线程阻塞的方法有哪些" class="headerlink" title="使线程阻塞的方法有哪些"></a>使线程阻塞的方法有哪些</h3><p>sleep()    suspend()   yield   wait()   join()</p><p>suspend e()使线程进入阻塞状态，只有对应的resume e()被调用的时候，线程才会进入可执行状态。(不建议用，容易发生死锁)</p><p>yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。(暂停当前正在执行的线程，并执行其他线程，且让出的时间不可知)</p><p>join()也叫线程加入。是当前线程A调用另一个线程B的join()方法，当前线程转A入阻塞状态，直到线程B运行结束，线程A才由阻塞状态转为可执行状态。</p><h3 id="Java中有哪些线程池"><a href="#Java中有哪些线程池" class="headerlink" title="Java中有哪些线程池"></a>Java中有哪些线程池</h3><ol><li>newCachedThreadPool创建一个可缓存线程池程</li><li>newFixedThreadPool 创建一个定长线程池</li><li>newScheduledThreadPool 创建一个周期性执行任务的线程池</li><li>newSingleThreadExecutor 创建一个单线程化的线程池</li></ol><p>newCachedThreadPool：一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p><p>newFixedThreadPool ：创建一个指定工作线程数量的线程池，每当提交一个任务就创建一个工作线程，当线程 处于空闲状态时，它们并不会被回收，除非线程池被关闭了，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列（没有大小限制）中。</p><p>newScheduledThreadPool：它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，它可安排给定延迟后运行命令或者定期地执行。这类线程池主要用于执行定时任务和具有固定周期的重复任务</p><p>newSingleThreadExecutor ：这类线程池内部只有一个核心线程，以无界队列方式来执行该线程，这使得这些任务之间不需要处理线程同步的问题，它确保所有的任务都在同一个线程中按顺序中执行，并且可以在任意给定的时间不会有多个线程是活动的</p><h3 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h3><p>数值型：整数类型：byte   short   int   long</p><p>数值型：浮点类型：float   double</p><p>字符型：char</p><p>布尔类型：booleann</p><h3 id="Java包装类"><a href="#Java包装类" class="headerlink" title="Java包装类"></a>Java包装类</h3><p>Integer   Long   Short   Byte   Character   Double   Float   Boolean   BigInterger   BigDecmail</p><h3 id="Java中Object类都有哪些方法"><a href="#Java中Object类都有哪些方法" class="headerlink" title="Java中Object类都有哪些方法"></a>Java中Object类都有哪些方法</h3><p>registernatives()   getClass()   hashCode()   equals()   clone()   toString()   notify()   notifyAll()   wait()   wait(long)   wait(long,int)   finalize()   共12个方法</p><h3 id="Java集合ArrayList和LinkedList区别"><a href="#Java集合ArrayList和LinkedList区别" class="headerlink" title="Java集合ArrayList和LinkedList区别"></a>Java集合ArrayList和LinkedList区别</h3><p>ArrayList：内存地址连续，所以查询效率大于增删</p><p>LinkedList：内存地址不联系，插入时只需要将节点掰开即可，所以增删效率大于查询</p><h3 id="Java中JDK1-7和1-8的区别"><a href="#Java中JDK1-7和1-8的区别" class="headerlink" title="Java中JDK1.7和1.8的区别"></a>Java中JDK1.7和1.8的区别</h3><p>JDK1.8新增3大重要特性：</p><ol><li>HashMap结构由：散列表（数组+链表）转换为红黑树</li><li>增加了Lambda表达式</li><li>接口中可以写方法体</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="2021/04/06/SpringBoot/"/>
      <url>2021/04/06/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h3 id="jfadsfasdffdsfasdfa"><a href="#jfadsfasdffdsfasdfa" class="headerlink" title="jfadsfasdffdsfasdfa"></a>jfadsfasdffdsfasdfa</h3><h3 id="fsdfsdfsdfdfdsfsdfasdfsdffsdf"><a href="#fsdfsdfsdfdfdsfsdfasdfsdffsdf" class="headerlink" title="fsdfsdfsdfdfdsfsdfasdfsdffsdf"></a>fsdfsdfsdfdfdsfsdfasdfsdffsdf</h3><p>fasdfasdf</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis面试题</title>
      <link href="2021/03/22/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/03/22/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h3><p>MyBatis是一个半ORM(对象映射关系)框架，它内部封装了JDBC，加载驱动，创建连接等一些里繁杂的过程，开发人员只需要关注如何编写SQL语句，可以严格控制SQL执行性能，灵活度高</p><h3 id="MyBatis工作流程简述"><a href="#MyBatis工作流程简述" class="headerlink" title="MyBatis工作流程简述"></a>MyBatis工作流程简述</h3><p>创建SqlSessionFactoryBuilder对象，调用build(inputstream)方法读取并解析配置文件，返回SqlSessionFactory对象<br>由SqlSessionFactory创建SqlSession 对象，没有手动设置的话事务默认开启<br>调用SqlSession中的api，传入Statement Id和参数，内部进行复杂的处理，最后调用jdbc执行SQL语句，封装结果返回。</p><ol><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量的代码冗余，不需要手动开关连接</li><li>很好的与各种数据库兼容，因为MyBatis使用JDBC来连接数据库。所以只要支持JDBC的数据库MyBatis都支持</li><li>能够与Spring很好的集成</li></ol><h3 id="MyBatis的缺点"><a href="#MyBatis的缺点" class="headerlink" title="MyBatis的缺点"></a>MyBatis的缺点</h3><ol><li>由于MyBatis是基于SQL语句编程，当SQL语句的编写工作量较大，尤其是字段多，关联表多时，对于开发人员编写 SQL 语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库一致性差，不能随意更换数据库</li></ol><h3 id="MyBatis框架适用场合"><a href="#MyBatis框架适用场合" class="headerlink" title="MyBatis框架适用场合"></a>MyBatis框架适用场合</h3><p>由于MyBatis专注于SQL本身，灵活度高，所以比较适合对性能要求较高，或者需求变化较多的项目，如互联网项目。</p><h3 id="MyBatis与Hibernate有哪些不同"><a href="#MyBatis与Hibernate有哪些不同" class="headerlink" title="MyBatis与Hibernate有哪些不同"></a>MyBatis与Hibernate有哪些不同</h3><ol><li>MyBatis不是一个完全的ORM框架，因为MyBatis需要开发人员自己编写SQL语句</li><li>Hibemate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用Hibernate开发可以节省很多diamagnetic，提高效率</li></ol><h3 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h3><ol><li>#{}是预编译处理，${}是字符串替换</li><li>MyBatis在处理#{}时，会将SQL中的#{}替换为？,调用PreparedStatement的set方法来赋值</li><li>MyBatis在处理${}替换成变量的值</li><li>使用#{}可以有效防止SQL注入，提高系统安全性。<strong>一般能用#{}就别用${}</strong></li></ol><h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办</h3><ol><li><p>通过在查询的SQL语句中定义字段名的别名，让字段名和实体类的属性名一致</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=”selectorder” parametertype=”<span class="keyword">int</span>” resultetype=”me.gacl.domain.order”&gt;</span><br><span class="line">select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过<resultMap>来映射字段名和实体类属性名的一一对应关系</resultMap></p></li></ol><h3 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a>模糊查询like语句该怎么写</h3><ol><li><p>在Java代码中添加SQL通配符</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “%smi%”;</span><br><span class="line">   list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br><span class="line">   &lt;select id=”selectlike”&gt;</span><br><span class="line">       select * from foo where bar like #&#123;value&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><p>在SQL语句中拼接通配符，但是会引起SQL注入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">    list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br><span class="line">    &lt;select id=”selectlike”&gt;</span><br><span class="line">         select * from foo where bar like <span class="string">&quot;%&quot;</span>$&#123;value&#125;<span class="string">&quot;%&quot;</span></span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h3><p>Dao接口就是mapper接扣，接口的全限名，就是映射文件中的namespace的值，接口的方法名就是映射文件中MappedStatement的id值，接口方法内的参数就是传递给SQL的参数</p><p>Dao接口的工作原理时JDK动态代理，MyBatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行接口方法所对应的MapperStatement所代表的SQL，然后将SQL执行结果返回</p><p>接口里的方法是不能重载的，因为时全限名+方法名的报错和寻找策略</p><h3 id="MyBatis是如何进行分页的，分页插件的原理是什么"><a href="#MyBatis是如何进行分页的，分页插件的原理是什么" class="headerlink" title="MyBatis是如何进行分页的，分页插件的原理是什么?"></a>MyBatis是如何进行分页的，分页插件的原理是什么?</h3><p>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果执行的内存分页，而非物理分页，可以在SQL内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用MyBatis提供插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL,然后重写SQL，根据dialect方言，添加对应的物理分页语句和物理分页参数</p><h3 id="MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>MyBatis仅支持一对一关联对象和一对多查询关联集合对象的延迟加载，在MyBatis配置文件中，可以配置是否启用延迟加载(lazyLoadingEnabled=true|false)</p><p>延迟加载的基本原理就是，似乎用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器 invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询出来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用</p><h3 id="MyBatis提供了9种动态SQL标签"><a href="#MyBatis提供了9种动态SQL标签" class="headerlink" title="MyBatis提供了9种动态SQL标签"></a>MyBatis提供了9种动态SQL标签</h3><p><strong>trim|where|set|foreach|if|choose|when|otherwise|bind</strong></p><h3 id="MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？"><a href="#MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？" class="headerlink" title="MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？"></a>MyBatis的xml映射文件中，不同的xml映射文件，id是否可以重复？</h3><p>不同的xml映射文件，如果配置了namespace，那么id可以重复，如果没有配置，那么不能重复。</p><p>原因就是namespace+id作为Map&lt;String,MappedStatement&gt; 的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据相互覆盖，有了namespace,自然id就可以重复，namespace不同，namespace+id自然也就不同</p><h3 id="Mybatis的一级，二级缓存"><a href="#Mybatis的一级，二级缓存" class="headerlink" title="Mybatis的一级，二级缓存"></a>Mybatis的一级，二级缓存</h3><ol><li>一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session,当Session flush或close之后，该Session中的所有Cache就将清空，默认打开一级皇城</li><li>二级缓存与一级缓存其机制相同，默认也是采用PerpetualCache，HashMap存储，不同在于其作用域为mapper(Namespace)，并且可自定义存储源，如Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口（可用来保存对象的状态）可在它的映射文件中配置<cache></cache></li><li>对于缓存数据更新机制，当某一个作用域（一级缓存Session/二级缓存Namespaces）进行了C/U/D操作后，默认该作用域下所有select中的缓存将被clear</li></ol><h3 id="Mybatis实现一对一有几种方式？具体是怎么操作的？"><a href="#Mybatis实现一对一有几种方式？具体是怎么操作的？" class="headerlink" title="Mybatis实现一对一有几种方式？具体是怎么操作的？"></a>Mybatis实现一对一有几种方式？具体是怎么操作的？</h3><p>有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在resultMap里面配置association节点一对一的类就可以完成；嵌套查询是先查一个表，根据这个表里的结果的外键id，再去另外一个表里查询数据，也是通过associtation配置，但另外一个表的查询通过select属性配置</p><h3 id="MyBatis实现一对多有几种方式，具体是怎么操作的？"><a href="#MyBatis实现一对多有几种方式，具体是怎么操作的？" class="headerlink" title="MyBatis实现一对多有几种方式，具体是怎么操作的？"></a>MyBatis实现一对多有几种方式，具体是怎么操作的？</h3><p>有联合查询和嵌套查询，联合查询时几个表联合查询，只查询一次，通过再resultMap里面colllection节点配置一对多的类就可以完成；嵌套查询是先查一个表，根据这个表里面的结果的外键id，再去另外一个表里查询数据，也是通过配置collection，但另外一个表的查询通过select节点配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-枚举</title>
      <link href="2021/03/20/Java%E5%9F%BA%E7%A1%80%E6%9E%9A%E4%B8%BE/"/>
      <url>2021/03/20/Java%E5%9F%BA%E7%A1%80%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举的说明"><a href="#枚举的说明" class="headerlink" title="枚举的说明"></a>枚举的说明</h2><ol><li>类的对象是固定的确定的，就可以称为枚举类</li><li>需要定义一组常量时，强烈建议使用枚举类</li><li>如果枚举中只有一个对象，则可以作为单例模式的实现方式</li></ol><h3 id="如何实现自定义枚举类："><a href="#如何实现自定义枚举类：" class="headerlink" title="如何实现自定义枚举类："></a>如何实现自定义枚举类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line"><span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"><span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">    <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"><span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK-5-0新增使用enum定义枚举类："><a href="#JDK-5-0新增使用enum定义枚举类：" class="headerlink" title="JDK 5.0新增使用enum定义枚举类："></a>JDK 5.0新增使用enum定义枚举类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line"> AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">     <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用enum定义枚举类后，枚举类常用方法（基于java-lang-Enum类）："><a href="#使用enum定义枚举类后，枚举类常用方法（基于java-lang-Enum类）：" class="headerlink" title="使用enum定义枚举类后，枚举类常用方法（基于java.lang.Enum类）："></a>使用enum定义枚举类后，枚举类常用方法（基于java.lang.Enum类）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Season1 summer = Season1.SUMMER;</span><br><span class="line">        <span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">        System.out.println(summer.toString());</span><br><span class="line"><span class="comment">//        System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        <span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">        Season1[] values = Season1.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">            System.out.println(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        Thread.State[] values1 = Thread.State.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">            System.out.println(values1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">        Season1 winter = Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">        <span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">        System.out.println(winter);</span><br></pre></td></tr></table></figure><h3 id="使用enum定义枚举类后，如何让枚举类对象分别实现接口"><a href="#使用enum定义枚举类后，如何让枚举类对象分别实现接口" class="headerlink" title="使用enum定义枚举类后，如何让枚举类对象分别实现接口"></a>使用enum定义枚举类后，如何让枚举类对象分别实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring概述以及IOC理论推导</title>
      <link href="2021/03/12/Spring%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/"/>
      <url>2021/03/12/Spring%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/03/12/Spring%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/Users\34005\AppData\Roaming\Typora\typora-user-images\image-20210312164542470.png" alt="image-20210312164542470"></p><h2 id="一-什么是Spring"><a href="#一-什么是Spring" class="headerlink" title="一.什么是Spring"></a>一.什么是Spring</h2><p>Spring：春天—-&gt;给软件行业带来春天</p><p>2002年，Rod Jahnson首次推出了Spring框架雏形 interface21 框架</p><p>2004年3月24日，Spring框架以 interface21框架为基础，经过重新设计，发布了1.0正式版</p><p>Spring理念：<strong>使现有的技术更加实用，本身就是一个大杂烩，整合现有框架技术</strong></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>Spring 是一个开源免费的框架，容器</p></li><li><p>Spring 是一个轻量级的框架，非入侵式的</p></li><li><p><strong>控制反转IOC，面向对象AOP</strong></p></li><li><p>对事物的支持，对框架的支持</p></li><li><p>……</p><p>总结：<strong>Spring 是一个轻量级控制反转的（IOC）和面向切面（AOP）的容器（框架）</strong></p></li></ol><h4 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUserBean</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User 是在应用内部创建以及维护的。所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器。<strong>控制权的转移就是所谓的控制反转</strong></p><h4 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h4><p>把依赖对象交给外部容器负责创建，那么TestUserBean类可以改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUserBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 构造器 参数，让容器把创建好的依赖对象注入进TestUserBean,也可以通过Setter方法注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestUserBean</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        user.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓依赖注入就是：<strong>在运行期间，由外部容器动态地将依赖对象注入到组件中</strong></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis动态SQL</title>
      <link href="2021/03/06/MyBatis%E5%8A%A8%E6%80%81SQL/"/>
      <url>2021/03/06/MyBatis%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">元素</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><if></if></td><td align="center">单条件分支，成立就执行，不成立就跳过</td></tr><tr><td align="center"><choose><when><otherwize></otherwize></when></choose></td><td align="center">多条件分支，从中选择符合条件的执行，都不满足，走最后</td></tr><tr><td align="center"><foreach></foreach></td><td align="center">循环，常用于in语句</td></tr><tr><td align="center"><where><trim><set></set></trim></where></td><td align="center">SQL拼接，字符处理</td></tr><tr><td align="center"><bind></bind></td><td align="center">OGINL表达式创建一个变量，绑定到mapper上下文，用于模糊查询SQL中</td></tr></tbody></table><p><strong>MyBatis官方文档动态SQL地址:</strong>==<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html==">https://mybatis.org/mybatis-3/zh/dynamic-sql.html==</a></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMenuByConditions&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Menu&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MenuResult&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectMenuVo&quot;</span>/&gt;</span></span><br><span class="line">        where 1 = 1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;menuId != null and menuId != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and menu_id = #&#123;menuId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose,when,otherwise"></a>choose,when,otherwise</h3><p>传入title就按title查询，如果传入author就按author查询，如果两个条件都不满足，则用otherwise里的条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    AND featured = 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>如果有至少一个if条件满足，则前面会自定加上where,如果一个条件也不满足，则不会出现where</p><p>where元素只会在元素返回任何内容的情况下才会插入”WERE”子句，而且，若子句的开头为”AND”或”OR”，where元素会自动将他们去掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 元素会动态地在首行插入 SET 关键字，并会删掉而外的逗号（这些逗号是在使用条件语句给列赋值时引入的）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>可以和 where 语句达到相同的功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以和 set 语句达到相同的功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态SQL的另一个常见的使用场景时对集合的遍历，（尤其是在构建IN语句的时候）</p><p>可以将任何可迭代对象（如List，Set等）,Map对象或者数组对象作为集合参数传递给foreach。当使用可迭代对象或数组时，index是当前迭代的序号，itme的值是本次迭代获取到的元素，当使用Map对象，（Map.Entry对象的集合）时，index是键，item是值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个MyBatis程序</title>
      <link href="2021/03/04/%E7%AC%AC%E4%B8%80%E4%B8%AAMyBatis%E7%A8%8B%E5%BA%8F/"/>
      <url>2021/03/04/%E7%AC%AC%E4%B8%80%E4%B8%AAMyBatis%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个MyBatis程序"><a href="#第一个MyBatis程序" class="headerlink" title="第一个MyBatis程序"></a>第一个MyBatis程序</h2><p><strong>思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试</strong></p><h4 id="1-搭建数据库"><a href="#1-搭建数据库" class="headerlink" title="1.搭建数据库"></a>1.搭建数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;mybatis&#96;;</span><br><span class="line">USE &#96;mybatis&#96;;</span><br><span class="line">CREATE TABLE &#96;user&#96;(</span><br><span class="line">&#96;id&#96; INT(20) NOT NULL PRIMARY KEY,</span><br><span class="line">&#96;name&#96; VARCHAR(30) DEFAULT NULL,</span><br><span class="line">&#96;pwd&#96;VARCHAR(30) DEFAULT NULL</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;) VALUES</span><br><span class="line">(1,&#39;张三&#39;,&#39;123qwe&#39;),</span><br><span class="line">(2,&#39;李四&#39;,&#39;456rty&#39;),</span><br><span class="line">(3,&#39;王五&#39;,&#39;789uio&#39;)</span><br></pre></td></tr></table></figure><h4 id="2-导入MyBatis相关Jar包"><a href="#2-导入MyBatis相关Jar包" class="headerlink" title="2.导入MyBatis相关Jar包"></a>2.导入MyBatis相关Jar包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-编写MyBatis核心配置文件"><a href="#3-编写MyBatis核心配置文件" class="headerlink" title="3.编写MyBatis核心配置文件"></a>3.编写MyBatis核心配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yanghao3612981&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每一个 Mapper.XML 都需要再Mybatis核心配置文件中注册！！！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/yang/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写MyBatis工具类"><a href="#4-编写MyBatis工具类" class="headerlink" title="4.编写MyBatis工具类"></a>4.编写MyBatis工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//sqlSessionFactory --&gt; sql Session</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory; <span class="comment">//提升作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//使用Mybatis第一步：获取sqlSessionFactory对象</span></span><br><span class="line">            String resouce = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resouce);<span class="comment">//读Mybatis配置文件</span></span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);    <span class="comment">//构建session工厂，通过build把这个流加载进来</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有了SqlSessionFactory,就可以从中获得 SqlSession 的实例了</span></span><br><span class="line">    <span class="comment">//SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取SQlSession连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-创建实体类"><a href="#5-创建实体类" class="headerlink" title="5.创建实体类"></a>5.创建实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;  <span class="comment">//id</span></span><br><span class="line">   <span class="keyword">private</span> String name;   <span class="comment">//姓名</span></span><br><span class="line">   <span class="keyword">private</span> String pwd;   <span class="comment">//密码</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造,有参,无参</span></span><br><span class="line">   <span class="comment">//set/get</span></span><br><span class="line">   <span class="comment">//toString()</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-编写Mapper（Dao）接口类"><a href="#6-编写Mapper（Dao）接口类" class="headerlink" title="6.编写Mapper（Dao）接口类"></a>6.编写Mapper（Dao）接口类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yang.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserMapper相当于UserDao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据ID查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByid</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert（添加）一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update（修改）一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete（删除）一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-编写Mappper-xml配置文件"><a href="#7-编写Mappper-xml配置文件" class="headerlink" title="7.编写Mappper.xml配置文件"></a>7.编写Mappper.xml配置文件</h4><ul><li>namespace十分重要，不能写错！</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace绑定一个对应的Dao/Maper接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.yang.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- select查询语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.yang.pojo.User&quot;</span>&gt;</span>    <span class="comment">&lt;!-- ID相当于重写方法的名字 resultType返回类型，resultMap返回一个集合 --&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.yang.pojo.User&quot;</span>&gt;</span>    <span class="comment">&lt;!-- parameterType参数类型 --&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 对象中的属性，可以直接取出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.yang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.yang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        update mybatis.user set name = #&#123;name&#125;,pwd = #&#123;pwd&#125;  where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-编写测试类"><a href="#8-编写测试类" class="headerlink" title="8.编写测试类"></a>8.编写测试类</h4><ul><li>Junit包测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.yang.utils.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.获得 Sql&#x27;Session 对象</span></span><br><span class="line">        SqlSession sqlsession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行 SQL 方式一：getMapper</span></span><br><span class="line">        UserMapper userDao = sqlsession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭sqlSession</span></span><br><span class="line">        sqlsession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        User user = mapper.getUserByid(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改需要提交事务</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">int</span> res = mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;哈哈&quot;</span>,<span class="string">&quot;23333&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">int</span> ret = mapper.updUser(<span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;呵呵&quot;</span>,<span class="string">&quot;123123&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">int</span> ret = mapper.delUser(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可能会出现问题说明：Maven静态资源过滤问题"><a href="#可能会出现问题说明：Maven静态资源过滤问题" class="headerlink" title="可能会出现问题说明：Maven静态资源过滤问题"></a>可能会出现问题说明：Maven静态资源过滤问题</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 build 中配置 resources ,来防止资源导出失败问题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC处理事务</title>
      <link href="2021/03/04/JDBC%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/03/04/JDBC%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC处理事务"><a href="#JDBC处理事务" class="headerlink" title="JDBC处理事务"></a>JDBC处理事务</h2><h3 id="一-什么是事务"><a href="#一-什么是事务" class="headerlink" title="一 . 什么是事务"></a>一 . 什么是事务</h3><p>在人员管理系统中，删除一个人员，即要删除人员的基本资料，也要删除和该人员相关的信息，如：邮箱，文章等。这样，这些数据库操作语句就构成一个事务！</p><h3 id="二-事务必须满足四个条件（ACID）"><a href="#二-事务必须满足四个条件（ACID）" class="headerlink" title="二 . 事务必须满足四个条件（ACID）"></a>二 . 事务必须满足四个条件（ACID）</h3><ul><li><strong>事务的原子性（Atomicity）：</strong>事务必须时一个原子工作单元。对于一个事务内部的数据修改，要么全部执行，要么全部不执行</li><li><strong>一致性（Consistency）：</strong>事务执行后，数据库状态与其他业务规则保持一致。事务执行结果必须时使数据库从一个一致性状态转换为另一个一致性状态</li><li><strong>隔离性（Isolation）：</strong>事务独立运行。一个事务处理后的结果，影响了娶她事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。并发事务所作的修改必须与其它并发事务所作的修改隔离。事务查看数据时，数据所处的状态，要么是另一并发事务修改其之前的状态，要么是另一事务修改其之后的状态，事务不会查看处于中间状态的数据</li><li><strong>持久性（Durability）：</strong>事务完成后，其对系统的影响是永久性的。软，硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。</li></ul><h3 id="三-MySQL中的事务"><a href="#三-MySQL中的事务" class="headerlink" title="三 . MySQL中的事务"></a>三 . MySQL中的事务</h3><p>在默认情况下，MySQL每执行一条SQL语句，都是一个单独的事务。如果需要在一个事务中包含多条SQL语句，那么需要开启事务和结束事务。</p><ul><li>开启事务：start transaction</li><li>结束事务：connit 或rollback</li></ul><p>在执行SQL语句之前，先执行 start transaction ,这就开启了一个事务（事务的起点），然后可以去执行多条 SQL 语句，最后需要结束事务，commit 表示提交，即事务中的多条SQL语句所作出的影响会持久到数据库中，或者 rollback, 表示回滚到事务的起点，之前所作的所有操作都被撤销了。</p><h3 id="四-JDBC事务"><a href="#四-JDBC事务" class="headerlink" title="四  . JDBC事务"></a>四  . JDBC事务</h3><p>在JDBC中处理事务，都是通过Connection完成的</p><p><strong>同一事务中的所有操作，都在同一个Connection对象</strong></p><p>Connection 的三个方法与事务有关：</p><ul><li>setAutoCommit(boolean)：设置是否为自动提交事务，如果是true（默认值为true）表示自动提交，也就是每条执行的SLQ语句都是一个单独的事务，如果设置为false,那么相当于开启了事务了；<strong>con.setAutoCommit(false)表示开启事务</strong></li><li>commit()：提交结束事务</li><li>rollbak()：回滚结束事务</li></ul><h3 id="五-事务的隔离级别"><a href="#五-事务的隔离级别" class="headerlink" title="五  . 事务的隔离级别"></a>五  . 事务的隔离级别</h3><ol><li><p>事务的并发读问题</p><ul><li><strong>脏读（dirty read）</strong>：读取到另外一个事务未提交数据（不允许出来的事）；</li><li><strong>不可重复读（unrepeatable）</strong>：两次读取不一致</li><li><strong>虚读（幻读）（phantomread）</strong>：读到另一事务已提交的数据</li></ul></li><li><p>四大隔离级别</p><p>​    4个等级的事务隔离级别，在相同的数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题式不同的</p><ol><li><strong>SERIALIZABLE（串行化）</strong><ul><li><strong>不会出现任何并发问题，因为他是对同一数据的访问时串行的，并发访问的</strong></li><li><strong>性能最差</strong></li></ul></li><li><strong>REPEATABLE READ（可重复读）（MySQL）</strong><ul><li><strong>防止脏读和不可重复读，不能处理虚读</strong></li><li><strong>性能比SERIALIZABLE好</strong></li></ul></li><li><strong>READ COMMITTED（读已提交数据）（Oracle）</strong><ul><li><strong>防止脏读，不能处理不可重复读和虚读</strong></li><li><strong>性能比REPEATABLE READ好</strong></li></ul></li><li><strong>READ UNCOMMITTED（读未提交数据）</strong><ul><li><strong>可能出现任何事务并发问题，什么都不处理</strong></li><li><strong>性能最好</strong></li></ul></li></ol></li></ol><h3 id="六-MySQL隔离级别"><a href="#六-MySQL隔离级别" class="headerlink" title="六 . MySQL隔离级别"></a>六 . MySQL隔离级别</h3><p>MySQL的默认隔离级别为Repeatable read,可以通过下面语句查看：</p><blockquote><p>SELECT @@<code>TX_ISOLATION</code>;</p></blockquote><p>也可以通过下面语句来设置当前连接的隔离级别：</p><blockquote><p>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ</p></blockquote><h3 id="七-JDBC设置隔离级别"><a href="#七-JDBC设置隔离级别" class="headerlink" title="七 . JDBC设置隔离级别"></a>七 . JDBC设置隔离级别</h3><p>con.setTransactionIsolation(int level) :参数可选值如下：</p><ul><li>Connection.TRANSACTION_READ_UNCOMMITTED；</li><li>Connection.TRANSACTION_READ_COMMITTED；</li><li>Connection.TRANSACTION_REPEATABLE_READ；</li><li>Connection.TRANSACTION_READ_SERIALIZABLE。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis简介</title>
      <link href="2021/02/24/MyBatis%E7%AE%80%E4%BB%8B/"/>
      <url>2021/02/24/MyBatis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><p><img src="/2021/02/24/MyBatis%E7%AE%80%E4%BB%8B/fads.png"></p><ul><li>MyBatis是一款优秀的持久层框架</li><li>它支持定制化SQL,存储过程以及高级映射</li><li>MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的 XML 或注解来配置和映射原生类型，接口和 Java 的POJO（Plain Oid Java Objects,普通老式 Java对象）为数据库中的记录</li><li>MyBatis 本是appache的一个开源项目iBatis,2010年这个项目由appche software foundation 迁移到了 google code,并且改名为 MyBatis</li><li>2013年迁移到Github</li></ul><h3 id="如何获得-MyBatis"><a href="#如何获得-MyBatis" class="headerlink" title="如何获得 MyBatis"></a>如何获得 MyBatis</h3><ol><li>Maven仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>Github：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li><li>中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>数据持久化</p><ul><li>持久化就是数据在持久状态和瞬时状态妆化的过程</li><li>内存：<strong>断电即失</strong></li><li>数据库（JDBC）,IO文件持久化</li><li>生活：冷藏，罐头</li></ul><p><strong>为什么需要持久化？</strong></p><ul><li>有些对象不能让它丢掉</li><li>内存太贵</li></ul><h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><p>Dao层，Service层，Servlet层</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显</li></ul><h2 id="为什么需要MyBatis"><a href="#为什么需要MyBatis" class="headerlink" title="为什么需要MyBatis?"></a>为什么需要MyBatis?</h2><ul><li>帮助程序猿将数据存入到数据库中</li><li>方便</li><li>传统的JDBC代码太复杂。简化 &gt; 框架 &gt; 自动化</li><li>不用 MyBatis也可以。<strong>技术没有高低之分</strong></li></ul><p>优点：</p><ul><li>简单易学。更容易上手</li><li>灵活</li><li>SQL和代码分离，提高了可维护性</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供XML标签，支持编写动态SQL</li></ul><p><strong>使用的人多</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多种设计模式</title>
      <link href="2021/02/05/Java%E5%A4%9A%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/02/05/Java%E5%A4%9A%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA想弄的时候再和其他的点一起给他弄玩：）    AAAAAAAAAAAAAAAAAAAAAAAAAAA  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式（一）单例模式</title>
      <link href="2021/02/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/02/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Java设计模式（一）单例模式"><a href="#Java设计模式（一）单例模式" class="headerlink" title="Java设计模式（一）单例模式"></a>Java设计模式（一）单例模式</h2><p>单例模式（Singleton Patten）是Java中最简单的设计模式之一。这种类型的设计模式属于创建行模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建一个自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>单例模式具有典型的三个特点：</p><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。（自我实例化）</li><li>单例类必须给所有其他对象提供这一实例。（提供全局访问点）</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：由于单例模式只生成了一个实例，所以能够节约系统资源，减少性能开销，提高系统的效率，同时也能够严格控制客户对它的访问。<br><strong>缺点</strong>：也正是因为系统只只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。</p><h2 id="常见实现方式"><a href="#常见实现方式" class="headerlink" title="常见实现方式"></a>常见实现方式</h2><p>常见的单例模式实现方式有五种：饿汉式，懒汉式，双重检测锁式，静态內部式和枚举单例。而在这物种方式中饿汉式和懒汉式最为常见。</p><h3 id="饿汉式：线程安全"><a href="#饿汉式：线程安全" class="headerlink" title="饿汉式：线程安全"></a>饿汉式：线程安全</h3><p>调用效率高。但是不能延时加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo1 &#123;</span><br><span class="line">&#x2F;&#x2F;线程安全的</span><br><span class="line">    &#x2F;&#x2F;类初始化时，立即加载这个对象</span><br><span class="line">private static SingletonDemo1 instance &#x3D; new SingletonDemo1();</span><br><span class="line">    private SingletonDemo1()&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法没有加载同步块，所以它效率高</span><br><span class="line">public static SingletonDemo1 getInstance()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于该模式在加载类的时候对象就已经创建了，所以加载类的速度比较慢，但是获取对象的速度比较快，且是<strong>线程安全</strong>的</p><h3 id="懒汉式：线程不安全"><a href="#懒汉式：线程不安全" class="headerlink" title="懒汉式：线程不安全"></a>懒汉式：线程不安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo2 &#123;</span><br><span class="line">    &#x2F;&#x2F;线程不安全</span><br><span class="line">    private static SingletonDemo2 instance &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    private SingletonDemo2()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;运行时加载对象</span><br><span class="line">    public static SingletonDemo2 getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new SingletonDemo2();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度比较慢，且线程不安全。如果想要线程安全的话可以加上synchronized关键字，但是这样效率又会降低。</p><h3 id="懒汉式（双重同步锁）"><a href="#懒汉式（双重同步锁）" class="headerlink" title="懒汉式（双重同步锁）"></a>懒汉式（双重同步锁）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo3 &#123;</span><br><span class="line">    private static volatile SingletonDemo3 instance &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    private SingletonDemo3()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;运行时加载对象</span><br><span class="line">    public static SingletonDemo3 getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized (SingletonDemo3.class)&#123;</span><br><span class="line">                if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    instance &#x3D; new SingletonDemo3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式常见应用场景"><a href="#单例模式常见应用场景" class="headerlink" title="单例模式常见应用场景"></a>单例模式常见应用场景</h2><ol><li>网站计数器。</li><li>项目中用于读取配置文件的类</li><li>数据库连接池。</li><li>Sping中。每个<strong>Bean</strong>默认都是单例的，这样便于Sping容器进行管理</li><li>Servlet中Application</li><li>Windows中任务管理器，回收站</li><li>…</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5加密</title>
      <link href="2021/01/12/MD5%E5%8A%A0%E5%AF%86/"/>
      <url>2021/01/12/MD5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>]]></content>
      
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP页面验证码</title>
      <link href="2021/01/12/JSP%E9%A1%B5%E9%9D%A2%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>2021/01/12/JSP%E9%A1%B5%E9%9D%A2%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>制作验证码的关键在于生成图形的Servlet</p><hr><pre><code>package edu.yang.servlet;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class AuthImg extends HttpServlet &#123;    // 设置图形验证码中字符串的字体和大小    private Font myFont = new Font(&quot;Arial Black&quot;, Font.PLAIN, 16);    @Override    public void init() throws ServletException &#123;        super.init();    &#125;    // 生成随机颜色    Color getRandColor(int fc, int bc) &#123;        Random random = new Random();        if (fc &gt; 255)            fc = 255;        if (bc &gt; 255)            bc = 255;        int r = fc + random.nextInt(bc - fc);        int g = fc + random.nextInt(bc - fc);        int b = fc + random.nextInt(bc - fc);        return new Color(r, g, b);    &#125;    @Override    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        // 阻止生成的页面内容被缓存，保证每次重新生成随机验证码        response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);        response.setDateHeader(&quot;Expires&quot;, 0);        response.setContentType(&quot;image/jpeg&quot;);        // 指定图形验证码图片的大小        int width = 100, height = 20;        // 生成一张新图片        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        // 在图片中绘制内容        Graphics g = image.getGraphics();        Random random = new Random();        g.setColor(getRandColor(200, 250));        g.fillRect(1, 1, width - 1, height - 1);        g.setColor(new Color(102, 102, 102));        g.drawRect(0, 0, width - 1, height - 1);        g.setFont(myFont);        // 随机生成线条，让图片看起来更加杂乱        g.setColor(getRandColor(160, 200));        for (int i = 0; i &lt; 155; i++) &#123;            int x = random.nextInt(width - 1);// 起点的x坐标            int y = random.nextInt(height - 1);// 起点的y坐标            int x1 = random.nextInt(6) + 1;// x轴偏移量            int y1 = random.nextInt(12) + 1;// y轴偏移量            g.drawLine(x, y, x + x1, y + y1);        &#125;        // 随机生成线条，让图片看起来更加杂乱        for (int i = 0; i &lt; 70; i++) &#123;            int x = random.nextInt(width - 1);            int y = random.nextInt(height - 1);            int x1 = random.nextInt(12) + 1;            int y1 = random.nextInt(6) + 1;            g.drawLine(x, y, x - x1, y - y1);        &#125;        // 该变量用来保存系统生成的随机字符串        String sRand = &quot;&quot;;        for (int i = 0; i &lt; 6; i++) &#123;            // 取得一个随机字符            String tmp = getRandomChar();            sRand += tmp;            // 将系统生成的随机字符添加到图形验证码图片上            g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110)));            g.drawString(tmp, 15 * i + 10, 15);        &#125;        // 取得用户Session        HttpSession session = request.getSession(true);        // 将系统生成的图形验证码添加        session.setAttribute(&quot;rand&quot;, sRand);        g.dispose();        // 输出图形验证码图片        ImageIO.write(image, &quot;JPEG&quot;, response.getOutputStream());    &#125;    // 随机生成一个字符    public String getRandomChar() &#123;        int rand = (int) Math.round(Math.random() * 2);// 将0～2的小数四舍五入生成整数        long itmp = 0;        char ctmp = 0000;        // 根据rand的值来决定是生成一个大写字母、小写字母和数字        switch (rand) &#123;            // 生成大写字母的情形            case 1:                itmp = Math.round(Math.random() * 25 + 65);                ctmp = (char) itmp;                return String.valueOf(ctmp);            // 生成小写字母            case 2:                itmp = Math.round(Math.random() * 25 + 97);                ctmp = (char) itmp;                return String.valueOf(ctmp);            // 生成数字            default:                itmp = Math.round(Math.random() * 9);                return String.valueOf(itmp);        &#125;    &#125;    public static void main(String[] args) &#123;        AuthImg auth = new AuthImg();        //System.out.println(service);    &#125;&#125;</code></pre><hr><p>生成的图形验证码存在Session中（sRand）</p><p>JSP页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;!-- &lt;a href&#x3D;&quot;stus?opt&#x3D;loadStusList&quot;&gt;查询全部数据&lt;&#x2F;a&gt; --&gt;</span><br><span class="line">  $&#123;mag&#125;</span><br><span class="line">  &lt;form action&#x3D;&quot;stus?opt&#x3D;login&quot; method&#x3D;&quot;post&quot;&gt;&lt;br&gt;</span><br><span class="line">    账号:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;&lt;br&gt;</span><br><span class="line">    密码:&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pwd&quot;&gt;&lt;br&gt;</span><br><span class="line">    验证码:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;valistr&quot;&gt;</span><br><span class="line">    &lt;img id &#x3D; &quot;valiImage&quot; src&#x3D;&quot;AuthImg&quot; width&#x3D;&quot;&quot; height&#x3D;&quot;&quot; alt&#x3D;&quot;&quot;&#x2F;&gt;$&#123;yzmcw&#125;</span><br><span class="line">    &lt;a href&#x3D;&quot;&quot; onclick&#x3D;&quot;refresh()&quot;&gt;看不清？换一张&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">     &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;autologin&quot;&gt;自动登录&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;save.jsp&quot;&gt;没账号？点击注册&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;刷新验证码</span><br><span class="line">    function refresh() &#123;</span><br><span class="line">      document.getElementById(&quot;authImg&quot;).src &#x3D; &quot;authImg?now&#x3D;&quot; + new Date(); &lt;!-- 使用时间作为参数避免浏览器从缓存取图片 --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2021/01/12/JSP%E9%A1%B5%E9%9D%A2%E9%AA%8C%E8%AF%81%E7%A0%81/xg.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery事件与动画</title>
      <link href="2020/12/28/JQuery%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
      <url>2020/12/28/JQuery%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="JQuery中的事件"><a href="#JQuery中的事件" class="headerlink" title="JQuery中的事件"></a>JQuery中的事件</h2><p>jquery事件是对JavaScript事件的封装，常用事件分类：</p><ol><li>基础事件：鼠标事件；键盘事件；Window事件；表单事件</li><li>复合事件：鼠标光标悬停；鼠标连续点击</li></ol><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>鼠标事件是当用户在文档上移动或单击鼠标时而产生的事件</p><table><thead><tr><th>方法</th><th>描述</th><th>执行时机</th></tr></thead><tbody><tr><td>click()</td><td>触发或将函数绑定刀指定元素的click事件</td><td>单击鼠标时</td></tr><tr><td>mouseover()</td><td>触发或将函数绑定刀指定元素的mouseover事件</td><td>鼠标移过时</td></tr><tr><td>mouseout()</td><td>触发或将函数绑定到指定元素的mouseout()事件</td><td>鼠标移出时</td></tr><tr><td>mouseenter()</td><td>触发或将函数绑定到指定元素的mouseenter事件</td><td>鼠标进入时</td></tr><tr><td>ouseleave()</td><td>触发或将函数绑定到指定元素的mouseleave事件</td><td>鼠标指针离开时</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java空实现接口</title>
      <link href="2020/12/14/Java%E7%A9%BA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/"/>
      <url>2020/12/14/Java%E7%A9%BA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>有时候实现一个接口时里面有很多用不到的方法，可以使用空实现类<br>继承空实现类，要用什么方法就只用那个方法，不用去重写其他用不到的方法</p><p>例（接口类）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package Zero.Empty_realization;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *接口类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface  IfeText &#123;</span><br><span class="line">    public void add();</span><br><span class="line">    public void delete();</span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例（空实现类）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Zero.Empty_realization;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 空实现类（如果只需要执行一个增加方法，其他几个方法也要重写出来）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Empty_realization implements IfeText &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例（具体业务逻辑类）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package Zero.Empty_realization;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 增加类</span><br><span class="line"> * （继承空实现类Empty_realization,只实现增加，不用重写其他不需要的方法）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class add extends Empty_realization &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        &#x2F;&#x2F;实现增加逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP数据源及分层开发</title>
      <link href="2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/"/>
      <url>2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="DAO模式"><a href="#DAO模式" class="headerlink" title="DAO模式"></a>DAO模式</h2><p>Data Access Object(数据存取对象)<br>位于业务逻辑和持久化数据之间<br>实现对持久化数据的访问<br>DAO起着转换器的作用，把实体类转换为数据库中的记录<br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/DAOzy.png"></p><h2 id="DAO模式的组成部分"><a href="#DAO模式的组成部分" class="headerlink" title="DAO模式的组成部分"></a>DAO模式的组成部分</h2><p>DAO接口<br>DAO实现类<br>数据库连接和关闭工具类</p><p>prooperties配置文件<br>Java中的配置文件常为properties文件</p><ol><li>后缀为.properties</li><li>格式是 “键=值” 格式</li><li>使用 “#” 来注释</li></ol><p>##　Java中提供了Properties类来读取配置文件</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String getProperty(String)</td><td>用指定的键在此属性列表中搜索属性,通过参数key得到其所对应的值</td></tr><tr><td>Object setProperty(String key,String value)</td><td>调用Hashtable的方法put。通过调用基类的put()方法来设置键-值对</td></tr><tr><td>void load(InputStream inStream)</td><td>从输入流中读取属性列表（键和元素对）。通过对指定文件进行装载获取文件中所有键值对</td></tr><tr><td>void clear()</td><td>清除所装载的键-值对，该方法由基类Hashtablb提供</td></tr></tbody></table><h2 id="使用实体类传递数据"><a href="#使用实体类传递数据" class="headerlink" title="使用实体类传递数据"></a>使用实体类传递数据</h2><p>数据访问代码和业务逻辑代码之间通过<font color="red">实体类</font>来传输数据<br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/stlcs.png"></p><h3 id="实体类特征"><a href="#实体类特征" class="headerlink" title="实体类特征"></a>实体类特征</h3><ol><li>属性一般使用private修饰</li><li>提供public修饰的get/set方法</li><li>实体类提供无参构造方法，根据业务提供有参构造</li><li>实现java.io.Serializable接口，支持序列化机制</li></ol><h2 id="Service的使用"><a href="#Service的使用" class="headerlink" title="Service的使用"></a>Service的使用</h2><p>Service其实就是一个接口，负责业务逻辑的<br>删除某个新闻类别（需要调用两个Dao的方法，配合工作）：<br>查询某个新闻分类下是否有新闻<br>若有，则提示无法删除<br>若无，删除该分类</p><h2 id="Dao层–数据访问接口层"><a href="#Dao层–数据访问接口层" class="headerlink" title="Dao层–数据访问接口层"></a>Dao层–数据访问接口层</h2><ol><li>主要负责和数据操作相关的事情</li><li>一般一个dao对应操作一张数据表</li><li>接口：NewsDao</li><li>接口实现类：NewsDaoImpl</li></ol><h2 id="Service层–业务逻辑层"><a href="#Service层–业务逻辑层" class="headerlink" title="Service层–业务逻辑层"></a>Service层–业务逻辑层</h2><ol><li>主要负责与业务逻辑相关操作，对dao层的封装和调用</li><li>接口NewsService</li><li>接口实现类：NewsServiceImpl</li></ol><h2 id="为什么需要分层"><a href="#为什么需要分层" class="headerlink" title="为什么需要分层"></a>为什么需要分层</h2><h3 id="JSP开发时分两层的弊端："><a href="#JSP开发时分两层的弊端：" class="headerlink" title="JSP开发时分两层的弊端："></a>JSP开发时分两层的弊端：</h3><p>展示逻辑与业务逻辑混合，或者业务代码与数据访问混合<br>编码职责不清，修改时互相影响，难以扩展和重用</p><h3 id="三层模式的划分"><a href="#三层模式的划分" class="headerlink" title="三层模式的划分"></a>三层模式的划分</h3><p><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/scjgdhf.png"><br>层与层之间的关系:<br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/cyczjdgx.png"><br>表示层依赖于业务逻辑层<br>业务逻辑层依赖于数据访问层</p><h3 id="分层原则："><a href="#分层原则：" class="headerlink" title="分层原则："></a>分层原则：</h3><ol><li>上层依赖下层，依赖关系不跨层</li><li>表示层不能直接访问数据访问层</li><li>上层调用下层的结果，取决于下层的实现</li><li>下一层不能调用下一层</li><li>下一次不能依赖上一层</li><li>下层的改变会影响上一层得到的结果</li><li>在上一层中不能出现下一层的概念：分工明确，各施其职</li></ol><h2 id="JSP动作标签"><a href="#JSP动作标签" class="headerlink" title="JSP动作标签"></a>JSP动作标签</h2><p>通过动作标签，程序员可以在JSP页面中把页面的显示功能部分封装起来，使整个页面更简洁和易于维护<br><a href="jsp:useBean">jsp:useBean</a><br>装载一个将在JSP页面中使用的JavaBean，发挥Java组件的重用的优势<br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/jspuseBean.png"><br><a href="jsp:include">jsp:include</a><br>把指定的文件插入正在生成的页面中<br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/jspinclude1.png"><br>jsp:include相当于把一个页面包含进来，这是一个动态包含。<br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/jspinclude2.png"><br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page&#x3D;&quot;adminSidebar.jsp&quot;&gt;&lt;&#x2F;jsp:include&gt;</span><br></pre></td></tr></table></figure><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>request.getRequestDispatcher().forward()请求转发<br>response.sendRedirect()重定向<br><a href="jsp:forward">jsp:forward</a><br><img src="/2020/12/13/JSP%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91/ymtz.png"><br>和request.getRequestDispatcher( ).forward( )：转发；效果是一样的</p>]]></content>
      
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP数据交互</title>
      <link href="2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
      <url>2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h2 id="获取表单提交的数据"><a href="#获取表单提交的数据" class="headerlink" title="获取表单提交的数据:"></a>获取表单提交的数据:</h2><h3 id="JSP（Java-Server-Pages）"><a href="#JSP（Java-Server-Pages）" class="headerlink" title="JSP（Java Server Pages）"></a>JSP（Java Server Pages）</h3><p><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/hpbdtjdsj.png"><br> <font color="red">从浏览器到服务器发送请求（request）</font><br> <font color="red">从服务器到浏览器接受请求（response）</font><br>【通过JSP来实现】</p><h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><p>输出对象，向客户端输出内容</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>请求对象；存储“客户端向服务端发送的请求信息”<br>request对象的常见方法:</p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">String getParameter(String name)</td><td align="center">根据请求的字段名key,返回字段值value</td></tr><tr><td align="center">String[] getParamaeterValues(String name)</td><td align="center">根据请求的字段名key,返回多个字段值value</td></tr><tr><td align="center">void setCharacterEncoding(编码格式)</td><td align="center">设置请求编码格式（Tomcat7以前默认ISO-8859-1，Tomcat8后UTF-8）</td></tr><tr><td align="center">getRequestDispatcher(“b.jsp”).forward(request,response)</td><td align="center">请求转发的方式跳转页面 A —&gt; B</td></tr><tr><td align="center">getServerContext()</td><td align="center">获取项目的ServletContext对象</td></tr></tbody></table><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>响应对象;用于响应客户端请求并向客户端输出信息</p><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><p>应用程序对象;类似于系统的全局变量，用于实现Web应用中的资源共享</p><p>常见方法：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void setAttribute(String key,Object value)</td><td>以key/value的形式保存对象值</td></tr><tr><td>Object getAttribute(String)</td><td>通过key获取对象值</td></tr><tr><td>String getRealPath(String path)</td><td>返回相对路径的真实路径</td></tr></tbody></table><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>用于记录会话状态的相关信息</p><h3 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h3><p>页面上下文对象</p><h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><p>页面对象<br>可以理解成this（当前对象，作用域最小）  作用域仅限于当前页面，只能在当前页面访问到attribute</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>配置对象</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h3><p>异常对象</p><h2 id="请求转发与重定向"><a href="#请求转发与重定向" class="headerlink" title="请求转发与重定向"></a>请求转发与重定向</h2><h3 id="请求转发（页面跳转了，请求的信息也返回给了客户端，但是页面地址不变）"><a href="#请求转发（页面跳转了，请求的信息也返回给了客户端，但是页面地址不变）" class="headerlink" title="请求转发（页面跳转了，请求的信息也返回给了客户端，但是页面地址不变）"></a>请求转发（页面跳转了，请求的信息也返回给了客户端，但是页面地址不变）</h3><p>用户进行了一次请求，但是服务器内部自动完成了跳转，服务器的行为无形中延长 了request作用域；所以用户看到的地址栏并不是应该看到的最后的跳转地址，依然是上一个地址<br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/qqzfyl.png"><br>RequestDispatche对象<br>foward()方法<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatche(&quot;要跳转的地址&quot;).forward(request,response);</span><br></pre></td></tr></table></figure><h3 id="重定向（页面跳转了，但是请求的信息不会转移）"><a href="#重定向（页面跳转了，但是请求的信息不会转移）" class="headerlink" title="重定向（页面跳转了，但是请求的信息不会转移）"></a>重定向（页面跳转了，但是请求的信息不会转移）</h3><p>用户进行了一次请求，服务器只是提示用户要跳转，要用户重新跳转新的页面，自己没有做跳转，所以不会返回信息，因为进行了第二次跳转，所以页面的地址变了<br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/cdxyl.png"><br>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(&quot;要跳转的地址&quot;)</span><br></pre></td></tr></table></figure><h3 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h3><table><thead><tr><th align="left"></th><th align="center">请求转发</th><th align="center">重定向</th></tr></thead><tbody><tr><td align="left">地址栏是否改变</td><td align="center">不变</td><td align="center">改变</td></tr><tr><td align="left">是否保存第一次请求时的数据</td><td align="center">保留</td><td align="center">不保留</td></tr><tr><td align="left">请求的次数</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="left">跳转发生的位置</td><td align="center">服务端</td><td align="center">客户端发出的第二次跳转</td></tr></tbody></table><h2 id="session中的setAttribute-作用域是一次会话"><a href="#session中的setAttribute-作用域是一次会话" class="headerlink" title="session中的setAttribute()作用域是一次会话"></a>session中的setAttribute()作用域是一次会话</h2><p>会话：一个会话就是浏览器和服务器之间的一次通话；会话可以在多次请求中保存和使用数据；一个会话就是在一段时间内，一个客户端与Web服务器的一串相关的交互过程；会话会话可以在多次请求中保存和使用数据：</p><p>public void setAttribute(String name,Object value);<br>用法：session.setAttribute(“userName”,”张三”);<br>public Object getAttribute(String name);<br>用法：String username=(String) session.getAttribute(“userName”)</p><h2 id="session与窗口的关系"><a href="#session与窗口的关系" class="headerlink" title="session与窗口的关系"></a>session与窗口的关系</h2><ol><li>每个session对象都与浏览器窗口对应，重新开启一个浏览器窗口，可以重新创建一个session对象<font color="red">（不同版本浏览器可能有所差别）</font></li><li>通过超链接打开的新窗口，新窗口的sesion与其父窗口的session相同</li></ol><p>session是一种机制，是服务端使用的用来记录同一个客户端状态的一个机制——session来判断哪个客户端：<br>    session.getid();<br>    public String getid();[得到当前客户端的编号，每一个session有一个唯一的sessionid]</p><p>同一个浏览器不管打开多少次都会显示同一个客户ID；不同的浏览器得到的客户ID不同<br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/sessionxyid.png"><br>session是<font color="red">单用户，多页面</font>可共享，session是保存在服务端的</p><h2 id="session对象常用方法："><a href="#session对象常用方法：" class="headerlink" title="session对象常用方法："></a>session对象常用方法：</h2><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>String getid()</td><td>获取sessionid</td></tr><tr><td>void setMaxInactiveInterval(int interval)</td><td>设定session的非法活动时间</td></tr><tr><td>int getMaxInactivelnterval()</td><td>获取session的有效非活动时间（以秒为单位）</td></tr><tr><td>void invalidate()</td><td>设置session对象失效</td></tr><tr><td>void setAttribute(String key,Object value)</td><td>以key/value的形式保存对象值</td></tr><tr><td>Object,getAttribute(String key)</td><td>通过key获取对象值</td></tr><tr><td>void removeAttribute(String key)</td><td>从session中删除指定名称key所对应的对象</td></tr></tbody></table><h2 id="会话的清除和过期"><a href="#会话的清除和过期" class="headerlink" title="会话的清除和过期"></a>会话的清除和过期</h2><p>Session的数据是在服务器端的，服务器报错的会话数据量会越来余额打，从而导致性能问题；假如没有清理机制，会导致性能问题或服务器崩溃</p><h3 id="1-程序主动请辞Session数据"><a href="#1-程序主动请辞Session数据" class="headerlink" title="1.程序主动请辞Session数据"></a>1.程序主动请辞Session数据</h3><p>手动设置失效：session.invalidate()    [程序里最常用的方法]<br>移除会话的一个属性：<br>    public void setAttribute(String name);<br>    用法：session.removeAttribute(“userName”);</p><h3 id="2-服务器主动清除长时间没有再次发出请求的Session"><a href="#2-服务器主动清除长时间没有再次发出请求的Session" class="headerlink" title="2.服务器主动清除长时间没有再次发出请求的Session"></a>2.服务器主动清除长时间没有再次发出请求的Session</h3><p>设置会话超时失效：<br>1.通过setMaxInactiveInterval()方法，<font color="red">单位是秒</font><br>public void setMaxInactiveInterval(int Interval);<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">session.setAttribute(&quot;login&quot;,admin);</span><br><span class="line">session.setMaxInactiveInterval(600);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>除了首页面，其他页面中也同样需要加入登录验证<br>有没有办法避免冗余代码的出现？<br>可以将一些共性的内容写入一个单独的文件中，然后通过include指令引用该文件</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>创建登录验证文件 loginControl.jsp<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String login &#x3D; (String)session.getAttribute(&quot;login&quot;);</span><br><span class="line">if(login &#x3D;&#x3D; null)&#123;</span><br><span class="line">response.sendRedirect(&quot;index.jsp&quot;)</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>在后台页面使用include指令引用登录验证文件<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file&#x3D;&quot;loginControl.jsp&quot; %&gt;</span><br></pre></td></tr></table></figure><h2 id="pageContext-request-session-application-三个范围对象对比："><a href="#pageContext-request-session-application-三个范围对象对比：" class="headerlink" title="pageContext  request  session  application 三个范围对象对比："></a>pageContext  request  session  application 三个范围对象对比：</h2><p>相同点：都可以存储属性<br>不同点:</p><ol><li><p>当前页面有效（页面跳转后无效）</p></li><li><p>request中存储的数据仅在一个请求中可用（请求转发有效；重定向后无效）</p></li><li><p>session中存储的数据在一个会话的有效期内可用（无论怎么跳转都有效；关闭/切换浏览器后无效）</p></li><li><p>application中存储的数据在整个Web项目中可用（整个项目运行期间都有效（切换服务器仍然有效）关闭服务，其他项目无效）</p><p><font color="red">以上范围对象，尽量使用最小的范围，因为 对象的范围越大，造成的性能损耗越大。</font></p></li></ol><h2 id="JSP常用内置对象的作用域"><a href="#JSP常用内置对象的作用域" class="headerlink" title="JSP常用内置对象的作用域"></a>JSP常用内置对象的作用域</h2><h3 id="page作用域"><a href="#page作用域" class="headerlink" title="page作用域"></a>page作用域</h3><p>对应的作用域访问对象为pageContext对象<br>page的作用域指本JSP页面的范围：<br>pageCOntext.setAttribute(键,值)<br>pageContext.getAttribute(键)</p><h3 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h3><p>对应的作用域访问对象为request对象<br>reques的作用域内的对象则是与客户端的请求绑定在一起<br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/requestzyy.png"></p><h3 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session作用域</h3><p>对应的作用域访问对象为session对象<br>session的作用域是一次会话<br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/sessionzyy.png"></p><h3 id="application作用域"><a href="#application作用域" class="headerlink" title="application作用域"></a>application作用域</h3><p>对应的作用域访问对象为application对象<br>application的作用域是面对整个Web应用程序<br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/applicationzyy.png"><br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/applicationzyy2.png"></p><h2 id="cookie的本质："><a href="#cookie的本质：" class="headerlink" title="cookie的本质："></a>cookie的本质：</h2><p>Web服务器保存在客户端的一小段文本信息</p><h2 id="cookie的作用"><a href="#cookie的作用" class="headerlink" title="cookie的作用"></a>cookie的作用</h2><ol><li>对特定对象的追踪</li><li>实现各种个性化服务</li><li>简化登录</li></ol><p>安全性能：容易泄露信息</p><h2 id="cookie以文件方式保存数据"><a href="#cookie以文件方式保存数据" class="headerlink" title="cookie以文件方式保存数据"></a>cookie以文件方式保存数据</h2><h3 id="创建cookie对象："><a href="#创建cookie对象：" class="headerlink" title="创建cookie对象："></a>创建cookie对象：</h3><p>Cookie newCookie = new Cookie(String key,String value);</p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据:"></a>添加数据:</h3><p>public void addCookie(Cookie cookie)<br>response.addCookie(newCookie);</p><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>public Cookie[] getCookies()    [返回的是一个数据]<br>Cookie[] cookies = request.getCookies();</p><h3 id="设置有效期"><a href="#设置有效期" class="headerlink" title="设置有效期"></a>设置有效期</h3><p>public void setMaxAge(int expiry)<br>只要打开一个浏览器访问一个服务器默认会发回来一个cookie名字是JsessionID,内容是一串数字和字母合起来。所以可以知道session是基于cookie的</p><h3 id="cookie对象的常用方法："><a href="#cookie对象的常用方法：" class="headerlink" title="cookie对象的常用方法："></a>cookie对象的常用方法：</h3><table><thead><tr><th>方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td>void setMaxAge(int expiry)</td><td align="center">设置cookie的有效期，以秒为单位</td></tr><tr><td>void setValue(String value)</td><td align="center">在cookie创建后，对cookie进行赋值</td></tr><tr><td>String getName()</td><td align="center">获取cookie的名称</td></tr><tr><td>String getValue()</td><td align="center">获取cookie的值</td></tr><tr><td>int getMaxAge()</td><td align="center">获取cookie的有效时间，以秒为单位</td></tr><tr><td>setPath(“/“)</td><td align="center">设置返回值</td></tr></tbody></table><p>加上setPath(“/“)这句话说明cookie对整个红尘是可见的，如果不加这句话cookie只对当前这个路径和它的子目录可见<br>当在cookie中使用中文的时候会出现中文乱码，此时要使用encode设置编码和decode解码实现：<br>示例：</p><h3 id="encode设置编码"><a href="#encode设置编码" class="headerlink" title="encode设置编码"></a>encode设置编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName &#x3D; URLEncoder.encode(userName,&quot;UTF-8&quot;);</span><br><span class="line">Cookie cookie &#x3D; new Cookie(&quot;username&quot;,userName);</span><br></pre></td></tr></table></figure><h3 id="decode解码"><a href="#decode解码" class="headerlink" title="decode解码"></a>decode解码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username &#x3D; cookies[i].getValue();</span><br><span class="line">username &#x3D; URLDecoder.decode(username,&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h2 id="cookie与session的对比："><a href="#cookie与session的对比：" class="headerlink" title="cookie与session的对比："></a>cookie与session的对比：</h2><h3 id="session-1"><a href="#session-1" class="headerlink" title="session"></a>session</h3><ol><li>在服务器端保存用户信息</li><li>session中保存的是Object类型</li><li>随着会话的结束而将其存储的数据销毁</li><li>保存重要的数据<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3></li><li>在客户端保存用户信息</li><li>cookie保存的是String类型</li><li>cookie可以长期保存在客户端</li><li>保存不重要的用户信息</li></ol><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><ol><li>JavaBean就是一个Java类</li><li>封装业务逻辑</li><li>封装数据</li></ol><h2 id="JavaBean的优势"><a href="#JavaBean的优势" class="headerlink" title="JavaBean的优势"></a>JavaBean的优势</h2><ol><li>解决代码重复编写，减少代码冗余</li><li>功能区分明确</li><li>提高了代码的维护性</li></ol><h2 id="JavaBean的功能上可以分为"><a href="#JavaBean的功能上可以分为" class="headerlink" title="JavaBean的功能上可以分为"></a>JavaBean的功能上可以分为</h2><ol><li><p>封装数据</p></li><li><p>封装业务<br> <img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/JavaBeangn.png"></p></li></ol><p><strong>封装数据的JavaBean</strong><br><img src="/2020/11/23/JSP%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/JavaBeanfzsj.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP动态网页开发基础</title>
      <link href="2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么学习B-S技术"><a href="#为什么学习B-S技术" class="headerlink" title="为什么学习B/S技术?"></a>为什么学习B/S技术?</h2><p>客户端   服务器   C（Client）/S（Server）有局限性，必须安装客户端<br>浏览器   服务器   B（Browser）/S（Server）无需安装客户端软件，也无需更新</p><h2 id="B-S与C-S的比较："><a href="#B-S与C-S的比较：" class="headerlink" title="B/S与C/S的比较："></a>B/S与C/S的比较：</h2><table><thead><tr><th align="center"></th><th align="center">B/S架构</th><th align="center">C/S架构</th></tr></thead><tbody><tr><td align="center">软件安装</td><td align="center">浏览器</td><td align="center">在响应速度和安全性上需要花费更多设计成本</td></tr><tr><td align="center">升级维护</td><td align="center">客户端零维护</td><td align="center">客户端需要单独维护和升级</td></tr><tr><td align="center">平台相关</td><td align="center">与操作系统平台的关系最小化</td><td align="center">对客户端操作系统一般有限制</td></tr><tr><td align="center">性能安全</td><td align="center">在响应速度和安全性上需要花费更多设计成本</td><td align="center">能充分发挥客户端处理能力，客户端响应快</td></tr></tbody></table><h2 id="什么是B-S技术"><a href="#什么是B-S技术" class="headerlink" title="什么是B/S技术"></a>什么是B/S技术</h2><p>B/S架构(浏览器/服务器):程序完全部署在服务器上</p><h2 id="B-S技术的工作原理"><a href="#B-S技术的工作原理" class="headerlink" title="B/S技术的工作原理"></a>B/S技术的工作原理</h2><p>B/S架构采用 <font color="red">请求/响应</font> 模式进行交互<br><img src="/2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/bsgzyl.png"></p><h2 id="URL-Uniform-Resource-Locator统一资源定位符"><a href="#URL-Uniform-Resource-Locator统一资源定位符" class="headerlink" title="URL(Uniform Resource Locator统一资源定位符)"></a>URL(Uniform Resource Locator统一资源定位符)</h2><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>例：http :// localhost:8888 / news/index.html<br>http:    协议部分<br>localhost:8888    主机IP地址:端口号<br>news/index.html    项目资源地址</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>图片服务器<br>文件服务器<br>数据库服务器<br>缓存服务器<br>应用服务器<br>Java Web  —&gt;  Web服务器</p><h2 id="常用的Web服务器"><a href="#常用的Web服务器" class="headerlink" title="常用的Web服务器"></a>常用的Web服务器</h2><p>Microsoft：IIS<br>Apache： Tomcat    （Tomcat是开源的，小型的免费的）<br>Oracle：WebLogic<br>IBM：WebSphere    （前两个商用的，安全级别更高）<br>Nginx    （稳定性高，占用内存小，并发能力强）</p><h2 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h2><p>Apache Jakarta的开源项目<br>轻量级应用服务器<br>开源,稳定,资源占用小<br>JSP/Servlet容器</p><h2 id="Tomcat目录结构"><a href="#Tomcat目录结构" class="headerlink" title="Tomcat目录结构"></a>Tomcat目录结构</h2><table><thead><tr><th align="center">目录</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/bin</td><td align="center">存放各种平台下用于启动和停止Tomcat的脚本文件</td></tr><tr><td align="center">/conf</td><td align="center">存放Tomcat服务器的各种配置文件</td></tr><tr><td align="center">/lib</td><td align="center">存放Tomcat服务器所需的各种JAR文件</td></tr><tr><td align="center">/logs</td><td align="center">存放Tomcat的日志文件</td></tr><tr><td align="center">/temp</td><td align="center">Tomcat运行时用于存放临时文件</td></tr><tr><td align="center">/webapps</td><td align="center">当发布Web应用时，默认情况下会将Web应用的文件存放于此目录中</td></tr><tr><td align="center">/work</td><td align="center">Tomcat把由JSP生成的Servlet放于此目录下</td></tr></tbody></table><h2 id="操作Tomcat注意事项："><a href="#操作Tomcat注意事项：" class="headerlink" title="操作Tomcat注意事项："></a>操作Tomcat注意事项：</h2><p>startup.bat        启动服务器<br>shutdown.bat     关闭服务器</p><p>开启服务器后关闭服务器建议不要直接点×关闭，应该点击 shutdown.bat关闭.防止出现啥乱七八糟的麻烦</p><p>端口号修改：conf/server.xml<br><img src="/2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/xgdk.png"></p><h2 id="JSP（Java-Server-Pages）概述"><a href="#JSP（Java-Server-Pages）概述" class="headerlink" title="JSP（Java Server Pages）概述:"></a>JSP（Java Server Pages）概述:</h2><ol><li>运行在服务端的Java页面</li><li>使用HTML嵌套Java代码实现</li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/JSPgzyl.png"></p><h2 id="JSP中的page指令："><a href="#JSP中的page指令：" class="headerlink" title="JSP中的page指令："></a>JSP中的page指令：</h2><p>通过设置内部的多个属性定义整个页面的属性<br>语法:<br>    <font color="red">&lt;%@ page 属性1=”属性值” 属性2=”属性值1,属性值2”…属性n=”属性值n”%&gt;</font></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性:"></a>常用属性:</h2><table><thead><tr><th align="center">属性</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">language</td><td align="center">指定JSP页面使用的脚本语言</td><td align="center">Java</td></tr><tr><td align="center">import</td><td align="center">通过该属性来引用脚本语言中使用到类文件</td><td align="center">无</td></tr><tr><td align="center">contentType</td><td align="center">用来指定JSP页面所采用的编码格式</td><td align="center">text/html,ISO-8859-1</td></tr></tbody></table><h2 id="JSP中的声明"><a href="#JSP中的声明" class="headerlink" title="JSP中的声明"></a>JSP中的声明</h2><p>语法：<br>    <font color="red">&lt;%! Java代码 %&gt;</font><br>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! int count &#x3D; 0; %&gt;</span><br></pre></td></tr></table></figure><p>上面代码声明了一个名为count的变量并将其初始化为0。声明的变量仅在页面第一次载入时由容器初始化一次，初始化后在后面的请求中一直保持该值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">String color[] &#x3D; &#123;&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;&#125;;</span><br><span class="line">String getColor(int i)&#123;</span><br><span class="line">return color[i];</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>也可以将上面的两个Java声明语句写在两个JSP声明标签中，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! </span><br><span class="line">String color[] &#x3D; &#123;&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;&#125;; </span><br><span class="line">%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">String getColor(int i)&#123;</span><br><span class="line">return color[i];</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><font color="red">方法声明后可在页面中多处调用</font></p><h2 id="JSP中的out对象"><a href="#JSP中的out对象" class="headerlink" title="JSP中的out对象"></a>JSP中的out对象</h2><ol><li>out对象是JSP的内置对象:无需实例化即可使用</li><li>实现数据的输出显示 </li></ol><p>out对象的方法:</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">print</td><td align="center">向页面输出显示</td></tr><tr><td align="center">println</td><td align="center">向页面输出显示,在结尾出加换行</td></tr></tbody></table><h2 id="JSP中的注释"><a href="#JSP中的注释" class="headerlink" title="JSP中的注释:"></a>JSP中的注释:</h2><ol><li>HTML的注释：<font color="red"><!--HTML注释--></font></li><li>JSP注释：<font color="red">&lt;%– JSP注释–%&gt;</font></li><li>在JSP脚本中注释：<font color="red">&lt;%//单行注释%&gt;；&lt;%/*多行注释*/%&gt;</font></li></ol><h2 id="网页输出文本"><a href="#网页输出文本" class="headerlink" title="网页输出文本"></a>网页输出文本</h2><h5 id="1-用Java语言输出文本"><a href="#1-用Java语言输出文本" class="headerlink" title="1.用Java语言输出文本"></a>1.用Java语言输出文本</h5><p>&lt;% out.print(“</p><h1>Hello Wrold</h1>“);%&gt;<p></p><h5 id="2-直接用HTML输出文本"><a href="#2-直接用HTML输出文本" class="headerlink" title="2.直接用HTML输出文本"></a>2.直接用HTML输出文本</h5><p><font color="red"><h1></h1></font>Hello Wrold<font color="red"></font></p><h6 id="3-使用-lt-out-print-gt-或-lt-out-printIn-gt-实现显示页面全部内容，这样做的弊端："><a href="#3-使用-lt-out-print-gt-或-lt-out-printIn-gt-实现显示页面全部内容，这样做的弊端：" class="headerlink" title="3. 使用&lt;% out,print(); %&gt;或&lt;% out.printIn(); %&gt;实现显示页面全部内容，这样做的弊端："></a>3. 使用&lt;% out,print(); %&gt;或&lt;% out.printIn(); %&gt;实现显示页面全部内容，这样做的弊端：</h6><p>①JAVA代码与HTML标签混在一起，可读性不好，不利于修改<br>②显示数据来自于数据库，数据库里的数据不能写死，要用变量来读取写在数据库的内容<br>③因为不方便所以这种方法用的比较少</p><h6 id="4-用变量的方法输出文本"><a href="#4-用变量的方法输出文本" class="headerlink" title="4.用变量的方法输出文本:"></a>4.用变量的方法输出文本:</h6><p>&lt;% String title = “Hello World”; %&gt;</p><p><font color="red"><h1></h1></font>&lt;%=title%&gt;<font color="red"></font><br>好处：直接在数据库里读的时候直接调用后台方法。<br>注：变量声明的时候要在最后加一个分号（；），在调用的时候前面要写（&lt;%=），但是最后不能写分号（；）</p><h2 id="JSP页面元素"><a href="#JSP页面元素" class="headerlink" title="JSP页面元素"></a>JSP页面元素</h2><p><img src="/2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/JSPymys.png"></p><h2 id="Web容器处理JSP文件请求"><a href="#Web容器处理JSP文件请求" class="headerlink" title="Web容器处理JSP文件请求:"></a>Web容器处理JSP文件请求:</h2><p>第一次处理需要经过3个阶段</p><ol><li>翻译阶段        （JSP文件翻译成Java文件）</li><li>编译阶段        （编译Java文件为Class文件）</li><li>执行阶段        （执行Class文件）<br><img src="/2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/JSPwjcl.png"><br>第一次请求之后,Web容器可以重用已经编译好的字节码文件:<br><img src="/2020/11/18/JSP%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/d2cqq.png"><br>如果对JSP文件进行了修改，Web容器会重新对JSP文件进行翻译和编译。</li></ol><h2 id="Web程序调试和排错："><a href="#Web程序调试和排错：" class="headerlink" title="Web程序调试和排错："></a>Web程序调试和排错：</h2><h5 id="404-找不到访问的页面或资源"><a href="#404-找不到访问的页面或资源" class="headerlink" title="404        找不到访问的页面或资源"></a>404        找不到访问的页面或资源</h5><p>排错方法：检查URL</p><h5 id="500错误—JSP页面代码有误"><a href="#500错误—JSP页面代码有误" class="headerlink" title="500错误—JSP页面代码有误"></a>500错误—JSP页面代码有误</h5><p>排错方法：检查myeclipse里的报错信息<br>排除错误：直接修改</p><h5 id="403-权限不足（访问a目录，但是a目录设置不可见）"><a href="#403-权限不足（访问a目录，但是a目录设置不可见）" class="headerlink" title="403    权限不足（访问a目录，但是a目录设置不可见）"></a>403    权限不足（访问a目录，但是a目录设置不可见）</h5><h5 id="页面无法显示"><a href="#页面无法显示" class="headerlink" title="页面无法显示"></a>页面无法显示</h5><p>排除错误：</p><h5 id="启动Tomcat服务"><a href="#启动Tomcat服务" class="headerlink" title="启动Tomcat服务"></a>启动Tomcat服务</h5><p>如果控制台上显示Tomcat服务已启动，观察端口号是否与预期端口号一致，按照实际端口号重新运行</p>]]></content>
      
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery选择器</title>
      <link href="2020/11/17/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>2020/11/17/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JQuery选择器"><a href="#JQuery选择器" class="headerlink" title="JQuery选择器"></a>JQuery选择器</h1><p>jQuery选择器类似于CSS选择器，用来选取网页中的元素<br>示例：$(“h3”).css(“background”,”#09F”);</p><h2 id="jQuery选择器分类："><a href="#jQuery选择器分类：" class="headerlink" title="jQuery选择器分类："></a>jQuery选择器分类：</h2><h3 id="1-通过CSS选择器选取元素"><a href="#1-通过CSS选择器选取元素" class="headerlink" title="1. 通过CSS选择器选取元素"></a>1. 通过CSS选择器选取元素</h3><p>①基本选择器<br>②层次选择器<br>③属性选择器</p><h3 id="2-通过过滤选择器选择元素"><a href="#2-通过过滤选择器选择元素" class="headerlink" title="2. 通过过滤选择器选择元素"></a>2. 通过过滤选择器选择元素</h3><p>①基本过滤选择器<br>②可见性过滤选择器</p><h2 id="基本选择器："><a href="#基本选择器：" class="headerlink" title="基本选择器："></a>基本选择器：</h2><p>基本选择器包括标签选择器，类选择器，ID选择器，并集选择器和全局选择器</p><table><thead><tr><th>名称</th><th>语法构成</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>标签选择器</td><td>element</td><td>根据给定的标签名匹配元素</td><td>$(“h2”) 选取所有h2标签</td></tr><tr><td>类选择器</td><td>class</td><td>根据给定的class匹配元素</td><td>$(“.title”) 选取所有class为title的元素</td></tr><tr><td>ID选择器</td><td>#id</td><td>根据给定的ID匹配元素</td><td>$(“#title”) 选取ID为title的元素</td></tr><tr><td>并集选择器</td><td>selector1,selector2,…selectorN</td><td>将每一个选择器匹配的元素合并后一起返回</td><td>$(“div,p,title”) 选取所有div,p和拥有class为title的元素</td></tr><tr><td>全局选择器</td><td>*</td><td>匹配所有元素</td><td>$(“*”) 选取所有元素</td></tr></tbody></table><p>例：</p><script>        $(function(){            //标签选择器            $("p").css("color","green");            //类选择器            console.log($(".nav").css("color","red"));            //ID选择器            $("#ul").css("color","blue");            //并集选择器            $(".nav,p").css("font-style","italic");            //全局选择器            $("*").css("font-weight","bold");        });</script><p><img src="/2020/11/17/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/jbxzq.png"></p><h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><p>层次选择器通过DOM元素之间的层次关系来获取元素</p><table><thead><tr><th>名称</th><th>语法构成</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>后代选择器</td><td>ancestor  descendant</td><td>选取ancestor元素里所有descendant(后代)元素</td><td>$(“#menu span”)选取menu下的span元素</td></tr><tr><td>子选择器</td><td>parent&gt;child</td><td>选取parent元素下的child(子)元素</td><td>$(“#menu&gt;span”) 选取#menu的子元素<span></span></td></tr><tr><td>相邻选择器</td><td>prev+next</td><td>选取紧邻prev元素之后的next元素</td><td>$(“h2+dl”) 选取紧邻<h2>元素之后的同辈元素<dl></dl></h2></td></tr><tr><td>同辈元素选择器</td><td>prev~sibings</td><td>选取prev元素之后的所有sibings元素</td><td>$(“h2~dl”) 选取<h2>元素之后所有的同辈元素<dl></dl></h2></td></tr></tbody></table><p>例：</p><script>        $(function(){            $("li").click(function(){                 $(this).css("color","red");            })            $(function(){                //后代选择器                $("ul li").css("color","red");  //全部li变红                //子选择器                  $("ul>ol").css("color","pink"); //全部ol变粉                //相邻选择器                $("h1+h2").css("text-decoration","underline");  //h2加上下划线                //同辈选择器                $("h1~p").css("font-weight","bold");    //所有p标签字体变粗            })        })</script><p><img src="/2020/11/17/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/cjxzq.png"></p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器通过HTML元素的属性来选择元素：a标签带有class属性</p><table><thead><tr><th>语法构成</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>[attrbute^=value]</td><td>选取给定属性是以某些特定值开始的元素</td><td>$(“[href^=’en’]”) 选取href属性值以en开头的元素</td></tr><tr><td>[attribute$=value]</td><td>选取给定属性是以某些特定值结尾的元素</td><td>$(“[href$=’.jpg’]”) 选取href属性值以.jpg结尾的元素</td></tr><tr><td>[attribute*=value]</td><td>选取给定属性是以包含某些值得元素</td><td>$(“[href*=’txt’]”) 选取href属性值中含有txt的元素</td></tr></tbody></table><script>        $(function(){            //根据属性名获取元素            $("#divs a[class]").css("background","pink");   //有class的 a标签 背景变粉            //根据属性值获取元素            $("#divs a[class='d']").css("color","blue");    //class为 d 的 a标签 字体变蓝            //除了某个属性值以外的元素            $("#divs a[class!='d']").css("color","red");    //class不为 d 的 a标签 字体变红            //根据属性值包含特定的值获取元素            $("#divs a[href^='www']").css("background","#c9cbcb");  //属性值href开头为 www 的标签背景变灰            $("#divs a[href$='.com']").css("font-style","italic");  //属性值href结尾为 .com 的标签字体变为斜体            $("#divs a[href*='taobao']").css("color","green");  //a标签 href 属性包含 taobao 的标签字体变为绿色        })    </script><p>     <img src="/2020/11/17/JQuery%E9%80%89%E6%8B%A9%E5%99%A8/sxxzq.png"></p><h2 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h2><table><thead><tr><th>语法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>:first</td><td>选取第一个元素</td><td>$(“li:first”) 选取所有<li>元素中的第一个</li><li>元素</li></td></tr><tr><td>:last</td><td>选取最后一个元素</td><td>$(“li:last”) 选取所有<li>元素中最后一个</li><li>元素</li></td></tr><tr><td>:not(selector)</td><td>选取去除所有与给定选择器匹配的元素</td><td>$(“li:not(.three)”) 选取class不是three的元素</td></tr><tr><td>:even</td><td>选取索引是偶数的所有元素（index从0开始）</td><td>$(“li:even”) 选取索引是偶数的所有<li>元素</li></td></tr><tr><td>:odd</td><td>选取索引是奇数的所有元素（index从0开始）</td><td>$(“li:odd”) 选取索引是奇数的所有<li>元素</li></td></tr><tr><td>:eq(index)</td><td>选取索引等于index的元素（index从0开始）</td><td>$(“li:eq(1)”) 选取索引等于1的<li>元素</li></td></tr><tr><td>:gt(index)</td><td>选取索引大于index的元素（index从0开始）</td><td>$(“li:gt(1)”) 选取索引大于1的<li>元素（注：小于1，不包括1）</li></td></tr><tr><td>:lt(index)</td><td>选取索引小于于index的元素（index从0开始）</td><td>$(“li:gt(1)”) 选取索引小于1的<li>元素（注：小于1，不包括1）</li></td></tr><tr><td>header</td><td>选取所有标题元素，如h1~h6</td><td>$(“:header” )选取网页中所有标题元素</td></tr><tr><td>:focus</td><td>选取当前获取焦点的元素</td><td>$(“:focus” )选取当前获取焦点的元素</td></tr><tr><td>:animated</td><td>选择所有动画</td><td>$(“:animated” )选取当前所有动画元素</td></tr></tbody></table><p>例：(主要的几个)</p><script>        $(function(){            $("ul li:first").css("color","red");        //ul里的第一个li变红            $("ul li:last").css("color","red");         //ul里的最后一个li变红            $("ul li:eq(2)").css("color","blue");       //ul里的第3个li变蓝            $("ol li:odd").css("color","royalblue");    //ol里的li奇数行变浅蓝            $("ol li:even").css("color","pink");        //ol里的li偶数行变浅蓝        });    </script><p>![](sxxzq (2).png)</p>]]></content>
      
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JQuery</title>
      <link href="2020/11/09/%E5%88%9D%E8%AF%86JQuery/"/>
      <url>2020/11/09/%E5%88%9D%E8%AF%86JQuery/</url>
      
        <content type="html"><![CDATA[<h1 id="JQuery是什么"><a href="#JQuery是什么" class="headerlink" title="JQuery是什么?"></a>JQuery是什么?</h1><p><img src="/2020/11/09/%E5%88%9D%E8%AF%86JQuery/Tu1.png"><br>JQuery是一个JavaScript库。<br>Jquery=js+query:可以看出JQuery主要是用来做查询的。<br>write less ，do more：JQuery能让我们对HTML文档的遍历和操作，事件处理，动画以及Ajax更加简单。</p><h1 id="为什么使用JQuery"><a href="#为什么使用JQuery" class="headerlink" title="为什么使用JQuery"></a>为什么使用JQuery</h1><h3 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h3><p>JQuery非常小,压缩包只有18KB左右</p><h3 id="强大的选择器"><a href="#强大的选择器" class="headerlink" title="强大的选择器"></a>强大的选择器</h3><p>JQuery不仅支持CSS里的所有选择器,还有JQuery独有的选择器</p><h3 id="出色的DOM操作封装"><a href="#出色的DOM操作封装" class="headerlink" title="出色的DOM操作封装"></a>出色的DOM操作封装</h3><p>JQuery封装了大量常用的DOM操作</p><h3 id="兼容性好"><a href="#兼容性好" class="headerlink" title="兼容性好"></a>兼容性好</h3><p>JQuery能够在不同浏览器中兼容,同时还修复了一些浏览器之间的差异</p><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>即对发生在同一个JQuery对象上的一组动作,可以直接连写而无需重复获取对象,使得JQuery的代码无比优雅</p><h3 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h3><p>当用JQuery找到带有”.class”类的全部元素,然后隐藏它们时,无需循环遍历每个返回的元素</p><h3 id="行为与结构分离"><a href="#行为与结构分离" class="headerlink" title="行为与结构分离"></a>行为与结构分离</h3><h3 id="丰富的插件支持"><a href="#丰富的插件支持" class="headerlink" title="丰富的插件支持"></a>丰富的插件支持</h3><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>任何人都可以自由使用并提出自己的意见</p><h3 id="JQuery的核心理念是-写得少-做得多-write-less-do-more"><a href="#JQuery的核心理念是-写得少-做得多-write-less-do-more" class="headerlink" title="JQuery的核心理念是:写得少,做得多(write less,do more)"></a>JQuery的核心理念是:写得少,做得多(write less,do more)</h3><h1 id="JQuery的作用"><a href="#JQuery的作用" class="headerlink" title="JQuery的作用"></a>JQuery的作用</h1><p>HTML元素选取,元素操作,CSS操作,HTML事件函数,JS特效和动画,HTML DOM遍历和修改,AJAX，Utilties</p><p>①访问和操作DOM元素【可以帮助我们对节点进行操作】<br>②控制页面样式<br>③对页面事件进行处理【页面处理方法是jQuery中特有的方法】<br>④扩展新的jQuery插件【可以利用其他人写的插件】<br>⑤与Ajax技术完美结合【帮我们处理了浏览器的兼容问题】</p><p>jQuery能做的JavaScript也都能做，但使用jQuery能大幅提高开发效率</p><p>化大为小，化繁为简，用来替代原生JavaScript</p><p>IE 6/7/8 兼容最高版本为jQuery1.9.1</p><p>优势：轻量级、强大的选择器、出色的DOM操作及其封装、可靠的事件处理机制、完善的Ajax、不污染顶级变量、出色的浏览器兼容性、链式操作方式、隐式迭代、行为层和结构层分离、丰富的插件支持</p><h1 id="如何使用JQuery"><a href="#如何使用JQuery" class="headerlink" title="如何使用JQuery?"></a>如何使用JQuery?</h1><h3 id="下载JQuery库"><a href="#下载JQuery库" class="headerlink" title="下载JQuery库"></a>下载JQuery库</h3><p>下载地址：<a href="https://code.jquery.com/">https://code.jquery.com/</a>  </p><h3 id="引入JQuery库"><a href="#引入JQuery库" class="headerlink" title="引入JQuery库"></a>引入JQuery库</h3><p>在HTML文件中使用script标签引入即可：</p><hr><pre><code>&lt;head&gt;    &lt;script src=&quot;jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><hr><h3 id="编写JQuery代码"><a href="#编写JQuery代码" class="headerlink" title="编写JQuery代码"></a>编写JQuery代码</h3><p>为了确保函数在DOM（docume object model 文档对象模型）元素都加载完成之后执行，所有JQuery代码都应写在JQuery入口函数中：</p><hr><pre><code>&lt;script&gt;    $(document).ready(function()&#123;        //JQuery代码...    &#125;);&lt;/script&gt;</code></pre><hr><h3 id="document-ready-与window-onload的区别"><a href="#document-ready-与window-onload的区别" class="headerlink" title="$(document).ready()与window.onload的区别"></a>$(document).ready()与window.onload的区别</h3><table><thead><tr><th align="left"></th><th>window.onload</th><th>$(document).ready()</th></tr></thead><tbody><tr><td align="left">执行时机</td><td>必须等待网页中所有的内容加载完毕后(包括图片、flash、视频等）才能执行</td><td>网页中所有DOM文档结构绘制完毕后即刻执行，可能与DOM元素关联的内容（图片、flash、视频等）并没有加载完</td></tr><tr><td align="left">编写个数</td><td>同一页面不能同时编写多个</td><td>同一页面能同时编写多个</td></tr><tr><td align="left">简化写法</td><td>无</td><td>$(function(){ //执行代码  }) ;简写形式</td></tr></tbody></table><h3 id="JQuery操作页面元素"><a href="#JQuery操作页面元素" class="headerlink" title="JQuery操作页面元素"></a>JQuery操作页面元素</h3><h4 id="使用css-方法为元素添加样式"><a href="#使用css-方法为元素添加样式" class="headerlink" title="使用css()方法为元素添加样式"></a>使用css()方法为元素添加样式</h4><p>css(“属性”,”属性值”) ;   [设置一个CSS属性]<br>css({“属性1”:”属性值1”,”属性2”:”属性值2”…}) ;   [同时设置多个CSS属性]<br>例：</p><hr><pre><code>$(&quot;div&quot;).css(&quot;width&quot;,&quot;100px&quot;);    //添加一个样式$(&quot;div&quot;).css(&#123;&quot;width&quot;:&quot;100px&quot;,&quot;height&quot;:&quot;100px&quot;&#125;)    //添加多个样式</code></pre><hr><h4 id="使用addClas-方法为元素添加样式-推荐"><a href="#使用addClas-方法为元素添加样式-推荐" class="headerlink" title="使用addClas()方法为元素添加样式(推荐)"></a>使用addClas()方法为元素添加样式(推荐)</h4><p>jQuery 对象.addClass(“样式名”);<br>例:</p><hr><pre><code>$(&quot;div&quot;).addClass(&quot;divs&quot;);</code></pre><hr><h4 id="使用show-hide-方法设置元素的显示和隐藏"><a href="#使用show-hide-方法设置元素的显示和隐藏" class="headerlink" title="使用show(),hide()方法设置元素的显示和隐藏"></a>使用show(),hide()方法设置元素的显示和隐藏</h4><p>例：:</p><hr><pre><code>$(&#39;div&#39;).show();    //显示div$(&#39;div&#39;).hide();    //隐藏div</code></pre><hr><h4 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h4><p>对一个对象进行多重操作，并将操作结果返回给该对象<br>例：</p><hr><pre><code>$(&quot;h2&quot;).css(&quot;background-color&quot;,&quot;#ccffff&quot;).next( ).css(&quot;display&quot;,&quot;block&quot;);</code></pre><hr><p>.next( ) 取回该选择器的下一个同胞元素；如：可以取到h2的下一个同胞元素p</p><h4 id="隐式迭代-1"><a href="#隐式迭代-1" class="headerlink" title="隐式迭代"></a>隐式迭代</h4><p>例：</p><hr><pre><code>&lt;body&gt;&lt;script&gt;    $(function()&#123;        $(&quot;li&quot;).css(&quot;color&quot;,&quot;red&quot;);;    &#125;);&lt;/script&gt;&lt;ul&gt;    &lt;li&gt;aaa&lt;/li&gt;    &lt;li&gt;bbb&lt;/li&gt;    &lt;li&gt;ccc&lt;/li&gt;    &lt;li&gt;ddd&lt;/li&gt;    &lt;li&gt;eee&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;</code></pre><hr><p><img src="/2020/11/09/%E5%88%9D%E8%AF%86JQuery/Tu2.png"><br>在jQuery中设置集合的属性，不需要遍历每一个元素，可以直接设置，这就是隐式迭代</p><h1 id="DOM对象和JQuery对象"><a href="#DOM对象和JQuery对象" class="headerlink" title="DOM对象和JQuery对象"></a>DOM对象和JQuery对象</h1><h3 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h3><p>用原生 JS 获取来的对象就是DOM对象</p><hr><pre><code>var objDOM=document.getElementById(&quot;myDiv&quot;);var objHTML=objDOM.innerHTML; </code></pre><hr><h3 id="JQuery对象"><a href="#JQuery对象" class="headerlink" title="JQuery对象"></a>JQuery对象</h3><p>JQuery方法获取的元素就是JQuery对象，能够使用jQuery中的方法<br>JQuery对象的本质就是利用 $ 对 DOM对象 包装后产生的对象（伪数组形式存储）</p><hr><pre><code>$(&quot;#title&quot;).html( );</code></pre><hr><h3 id="DOM对象转jQuery对象"><a href="#DOM对象转jQuery对象" class="headerlink" title="DOM对象转jQuery对象"></a>DOM对象转jQuery对象</h3><p>DOM对象转换为JQuery对象:    $(DOM对象)</p><hr><pre><code>￥（&#39;div&#39;）</code></pre><hr><p>JQuery对象转换为DOM对象（两种方式）</p><hr><pre><code>$(&#39;div&#39;)[index]        index是索引号$(&#39;div&#39;)get(index)        index是索引号</code></pre><hr><p>【不建议频繁的相互转化】</p><p>类型转换案例:</p><hr><pre><code>&lt;body&gt;&lt;video src=&quot;../DJ已就位.mp4&quot; muted&gt;&lt;/video&gt;&lt;script&gt;    //1.DOM对象转换为 JQuery对象    //(1-1)直接获取视频元素,得到的就是 JQuery对象    //$(&#39;video&#39;);    //(1-2)原生JS获取DOM对象    var myvideo = document.querySelector(&#39;video&#39;);    //myvideo.play();     //可以播放视频    //2.JQuery对象转换为DOM对象    //$(myvideo).play();    //JQuery中没有play方法    $(&#39;video&#39;)[0].play();       //转换后可以播放    $(&#39;video&#39;).get(0).play();   //另一种转换方式,视频也可以播放&lt;/script&gt;&lt;/body&gt;</code></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中对象及面向对象</title>
      <link href="2020/11/01/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/11/01/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><h2 id="Java中的基本数据类型"><a href="#Java中的基本数据类型" class="headerlink" title="Java中的基本数据类型"></a>Java中的基本数据类型</h2><ol><li>string（字符串类型）</li><li>boolean(布尔类型)</li><li>null(空类型)  【判断后的值是object】</li><li>undefined(未定义类型)</li><li>object(实例化的对象是一组数据或者功能的集合)</li></ol><h2 id="对象是包含属性和方法的集合体"><a href="#对象是包含属性和方法的集合体" class="headerlink" title="对象是包含属性和方法的集合体"></a>对象是包含属性和方法的集合体</h2><ol><li>属性</li><li>方法</li></ol><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象仅仅是一个概念或者编程思想<br>通过一种叫做原型的方式来实现面向对象编程</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="1-基于Object对象的方式创建对象"><a href="#1-基于Object对象的方式创建对象" class="headerlink" title="1.基于Object对象的方式创建对象"></a>1.基于Object对象的方式创建对象</h3><p>语法: var 对象名称 = new Object();<br>例:</p><hr><pre><code>    &lt;script&gt;        //利用 new Object 创建对象        //通过  . 添加属性和方法        var obj = new Object();        obj.uname = &#39;张三&#39;;        obj.age = 58;        obj.sex = &#39;男&#39;;        obj.sayHi = function()&#123;            console.log(&#39;Hi~&#39;);        &#125;        //(1)利用等号赋值的方法添加对象的属性和方法        //(2)每个属性和方法之间用;分号结束        console.log(obj.uname);        console.log(obj[&#39;age&#39;]);        obj.sayHi();    &lt;/script&gt;</code></pre><hr><h3 id="使用字面量赋值方式创建对象"><a href="#使用字面量赋值方式创建对象" class="headerlink" title="使用字面量赋值方式创建对象"></a>使用字面量赋值方式创建对象</h3><p>例:</p><hr><pre><code>    &lt;script&gt;    //利用对象字面量创建对象&#123;&#125;    //var obj = &#123;&#125;;   //创建了一个空的对象    var obj = &#123;        uname: &#39;张三&#39;,        age: 18,        sex: &#39;男&#39;,        sayHi: function()&#123;            console.log(&#39;Hi~&#39;);        &#125;    &#125;    //(1)里面的属性或者方法采取键值对的形式 键  属性    //(2)多个属性或方法中间用逗号隔开    //(3)方法冒号后面跟的是一个匿名函数    //2.使用对象    //(1).调用对象的属性 采取 对象名.属性名    console.log(obj.uname);    //(2.)调用属性的第二种方法 对象名[&#39;属性名&#39;]    console.log(obj[&#39;age&#39;]);    //(3.调用对象的方法)  sayHi   对象名.方法名    obj.sayHi();&lt;/script&gt;</code></pre><hr><h3 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h3><p>使用同一个接口不需要创建很多对象，减少产生大量的重复代码</p><p>①创建特定类型的对象<br>②通过this变量控制属性和方法，实现属性和方法的调用<br>③通过new操作符来创建对应的构造函数的实例，也就是对象</p><h4 id="调用构函数的4个步骤"><a href="#调用构函数的4个步骤" class="headerlink" title="调用构函数的4个步骤"></a>调用构函数的4个步骤</h4><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（this就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象<br>例:</li></ol><hr><pre><code>&lt;script&gt;    function Star(uname,age,sex)&#123;        this.name = uname;      //name是Star构造函数的属性,uname是Star构造函数的参数        this.age = age;        this.sex = sex;        this.sing = function(sang)&#123;            console.log(sang);        &#125;    &#125;    var ldh = new Star(&#39;刘德华&#39;,18,&#39;男&#39;);           //调用函数返回的一个对象    console.log(ldh);    console.log(ldh.name);    console.log(ldh[&#39;sex&#39;]);    //1.构造函数名字首字母大写    //2.构造函数不需要return就可以返回对象    //3.调用构造函数就必须使用new    //4.只要new Star() 调用函数就创建了一个对象ldh&#123;&#125;    //5.构造函数属性和方法前必须添加this&lt;/script&gt;</code></pre><hr><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="常见的内置对象："><a href="#常见的内置对象：" class="headerlink" title="常见的内置对象："></a>常见的内置对象：</h3><h4 id="1-String（字符串）对象"><a href="#1-String（字符串）对象" class="headerlink" title="1. String（字符串）对象"></a>1. String（字符串）对象</h4><p>length属性<br>indexOf( )方法、replace( )方法</p><h4 id="2-Date（日期）对象"><a href="#2-Date（日期）对象" class="headerlink" title="2. Date（日期）对象"></a>2. Date（日期）对象</h4><p>  get×××：获取年、月、日、时、分、秒等等<br>  set×××：设置年、月、日、时、分、秒等等</p><h4 id="3-Array（数组）对象"><a href="#3-Array（数组）对象" class="headerlink" title="3. Array（数组）对象"></a>3. Array（数组）对象</h4><p>  length属性<br>  sort( )、concat( )、join( )方法</p><h4 id="4-Boolean（逻辑）对象"><a href="#4-Boolean（逻辑）对象" class="headerlink" title="4. Boolean（逻辑）对象"></a>4. Boolean（逻辑）对象</h4><p>  true或者fals<br>  toString( )方法</p><h4 id="5-Math（算数）对象"><a href="#5-Math（算数）对象" class="headerlink" title="5. Math（算数）对象"></a>5. Math（算数）对象</h4><p>  round( )、max( )、min( )方法</p><h4 id="6-RegExp对象"><a href="#6-RegExp对象" class="headerlink" title="6. RegExp对象"></a>6. RegExp对象</h4><p>  RegExp是正则表达式的缩写</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>JavaScript中每一个构造函数都有一个prototype属性,指向另一个对象。prototypr就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有</p><p>我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象实例就可以共享这些方法</p><p>原型就是一个对象,也称为prototype为原型对象<br>原型的作用就三个字:共享方法</p><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>constructor主要用于记录该对象引用与哪个构造函数,可以让原型对象从新指向原来的构造函数。<br>例:</p><hr><pre><code>&lt;script&gt;    function Star(name,age)&#123;        this.uname = name;        this.age = age;    &#125;    // Star.prototype.sing = function()&#123;        .方法名是往prototype对象中添加一个方法    //          // &#125;    // Star.prototype.movie = function()&#123;    //     console.log(&quot;我会演电影&quot;);    // &#125;    Star.prototype = &#123;      //直接等于后面的对象的话会覆盖原有的prototype对象,没有constructor属性,需要手动添加        constructor: Star,  //添加一个constructor属性重新指回原构造函数        sing: function()&#123;            console.log(&quot;我会唱歌&quot;);        &#125;,        movie: function()&#123;            console.log(&quot;我会演电影&quot;);        &#125;    &#125;    var ldh = new Star(&quot;刘德华&quot;,18);    var zxy = new Star(&quot;张学友&quot;,19);    //console.log(Star.prototype);  有一个constructor属性指回构造函数本身    //console.log(ldh.__proto__);   有一个constructor属性指回构造函数本身    console.log(Star.prototype.constructor);    //输出Star构造函数    console.log(ldh.__proto__.constructor);     //输出Star构造函数    console.log(ldh.constructor == Star);       //true&lt;/script&gt;</code></pre><hr><h4 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h4><p>使用instanceof操作符检测对象类型<br>例:(判断foo是否是Foo的实例)</p><hr><pre><code>// 判断 foo 是否是 Foo 类的实例function Foo()&#123;&#125;var foo = new Foo();console.log(foo instanceof Foo)//true</code></pre><hr><h4 id="原型对象-1"><a href="#原型对象-1" class="headerlink" title="原型对象"></a>原型对象</h4><p>①每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象<br>②prototype就是通过调用构造函数而创建的那个对象实例的原型对象</p><p>例1:</p><hr><pre><code>&lt;script&gt;    function Star(name,age)&#123;        this.name = name;        this.age = age;    &#125;    Star.prototype.sing = function()&#123;   //构造函数中的方法写在原型对象中,避免开辟出更多的空间        console.log(&quot;会唱歌&quot;);    &#125;    var ldh = new Star(&quot;刘德华&quot;,18);    var zxy = new Star(&quot;张学友&quot;,19);    console.log(ldh.name);    ldh.sing();    zxy.sing();    console.log(ldh.sing==zxy.sing);    //一般情况下,公共属性定义到构造函数中,公共的方法定义到原型对象中&lt;/script&gt;</code></pre><hr><p>例2:(原型对象<strong>proto</strong>)</p><hr><pre><code>&lt;script&gt;    function Star(name,age)&#123;        this.uname = name;        this.age = age;    &#125;    Star.prototype.sing = function()&#123;        console.log(&quot;我会唱歌&quot;);    &#125;    var ldh = new Star(&quot;刘德华&quot;,18);    var zxy = new Star(&quot;张学友&quot;,19);    ldh.sing();    console.log(ldh);       //系统会默认自己添加一个__proto__指向我们构造函数的原型对象    console.log(ldh.__proto__ === Star.prototype);      //ture    //方法的查找规则:首先看 ldh 对象身上是否有 sing 方法,如果有就执行这个方法上的 sing 方法    //如果没有 sing 这个方法,因为有__proto__的存在,就去构造函数原型对象prototype中去找&lt;/script&gt;</code></pre><hr><h1 id="JavaScript继承"><a href="#JavaScript继承" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>①一个原型对象是另一个原型对象的实例<br>②一个原型对象包含着指向另一个原型的指针,相应的,另一个原型中也包含着指向另一个构造函数的指针,假如另一个原型又是另一个类型的实例,那么上述关系依然成立,如此层层递进,就构成了实例与原型的链条,这就是原型链</p><hr><pre><code>&lt;script&gt;    function Star(name,age)&#123;        this.uname = name;        this.age = age;    &#125;    Star.prototype.sing = function()&#123;        console.log(&quot;我会唱歌&quot;);    &#125;    var ldh = new Star(&quot;刘德华&quot;,18);    //1.只要是对象就有__proto__原型,指向原型对象    console.log(Star.prototype);    //里面也有一个__proto__    console.log(Star.prototype.__proto__ === Object.prototype); //true    //2.Star原型对象里面的__proto__指向的是 Object.prototype    console.log(Object.prototype.__proto__);    //null    //3.Object.prototype原型对象d里面的__proto__原型 指向为null&lt;/script&gt;</code></pre><hr><h2 id="构造函数和原型链之间的关系"><a href="#构造函数和原型链之间的关系" class="headerlink" title="构造函数和原型链之间的关系:"></a>构造函数和原型链之间的关系:</h2><p><img src="/2020/11/01/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Tu1.png"></p><ol><li>任何函数都具有一个  prototype  属性，该属性是一个对象</li><li>造函数的  prototype 对象默认都有一个  constructor  属性，指向  prototype  对象所在函数</li><li>通过构造函数得到的实例对象内部会包含一个指向构造函数的  prototype 对象的指针  <strong>proto</strong></li><li>所有实例都直接或间接继承了原型对象的成员</li></ol><h2 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h2><p>例:</p><hr><pre><code>function Humans()&#123;    this.clothing=[&quot;trousers&quot;,&quot;dress&quot;,&quot;jacket&quot;];&#125;function Man()&#123;  &#125;//继承了HumansMan.prototype=new Humans();var man1=new Man();man1.clothing.push(&quot;coat&quot;);alert(man1.clothing);var man2=new Man();alert(man2.clothing);</code></pre><hr><p>Man这个构造函数是把所有属性和方法共享；使用时会把数组中的信息进行一个应用。</p><h3 id="其中man1-clothing和man2-clothing输入的信息一样，为什么？"><a href="#其中man1-clothing和man2-clothing输入的信息一样，为什么？" class="headerlink" title="其中man1.clothing和man2.clothing输入的信息一样，为什么？"></a>其中man1.clothing和man2.clothing输入的信息一样，为什么？</h3><p>创建子类型的实例时，不能向父类型的构造函数中传递参数；我们可以使用借用构造函数来解决这样的问题。<br>【借用构造函数就是在子类构造函数中调用父类构造函数，来实现属性和方法的继承】</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply([thisOjb[,argArray]])<br>应用某一对象的一个方法，用另一个对象替换当前对象</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><hr><pre><code>&lt;script&gt;    function fn(x,y)&#123;        console.log(&quot;我想变成光&quot;);        console.log(this);  //指向函数的调用者window        console.log(x + y);    &#125;    var o = &#123;        name: &#39;andy&#39;    &#125;    //1.call()      可以调用函数    //fn.call();    //2.call(要指向的对象,参数1,参数2); 可以改变这个函数的this指向    fn.call(o,1,2);     //此时fn这个函数指向的就是 o 这个对象&lt;/script&gt;</code></pre><hr><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>有时也叫做伪经典继承<br>①将原型链和借用构造函数的技术组合到一块，发挥二者之长的一种继承模式<br>②使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript操作DOM对象</title>
      <link href="2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript操作DOM对象"><a href="#JavaScript操作DOM对象" class="headerlink" title="JavaScript操作DOM对象"></a>JavaScript操作DOM对象</h1><pre><code>1.DOM:是DocumentObjectModel的缩写,以及文档对象模型2.DOM通常分为三类:DOM Core(核心)`HTML-DOM和CSS-DOM</code></pre><hr><h2 id="DOM-Core"><a href="#DOM-Core" class="headerlink" title="DOM Core"></a>DOM Core</h2><p>DOM Core不是JavaScript的专属品,任何一种支持DOM的编辑器语言都可以使用它<br>它的用途不仅限于处理一种使用标记语言编写出来的文档如HTML文档<br>getElementById()/getElementByTagName()等方法都是 DOM Core的组成部分<br>例：使用Document.getElementByTagname(“input”)可获取页面中的&lt;“input”&gt;元素</p><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML-DOM"></a>HTML-DOM</h2><p>获取DOM模型中的某些对象、属性、既可以使用DOM-Core实现，也可以使用HTML-DOM实现<br>相对于DOM Core获取对象、属性而言，当使用HTML-DOM时，代码通常较为简单，只是它<br>的应用范围没有DOM Core广泛，仅适用于处理HTML文档</p><h2 id="CSS-DOM"><a href="#CSS-DOM" class="headerlink" title="CSS-DOM"></a>CSS-DOM</h2><p>CSS-DOM是针对CSS的操作，在JavaScript中，CSS-DOM技术的主要作用是获取和设置Style对象的各种属性，即CSS属性，通过改变style对象的各种属性，可以使用网页呈现出 各种对象的各种属性，即CSS属性，通过改变style对象的各种属性，可以使用网页呈现出各种不同的效果</p><hr><h1 id="节点和节点关系"><a href="#节点和节点关系" class="headerlink" title="节点和节点关系"></a>节点和节点关系</h1><p>简介:DOM是以树状结构组织的HTML文档,根据DOM概念,我们可以知道,HTML文档值的每个标签或元素都是一个节点,在DOM中是这样规定的<br>1.整个文档是一个文档节点<br>2.每个HTML标签是一个元素节点<br>3.包含在HTML元素中的文本是文本节点<br>4.每个HTML属性是一个属性节点<br>5.注释属于注释节点</p><hr><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src = &quot;#&quot; alt=&quot;音乐&quot; id=&quot;Music&quot;&gt;    &lt;h1&gt;对音乐感兴趣&lt;/h1&gt;    &lt;p&gt;DOM 应用&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>关系图:<br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/GuanXiTu.png"><br>6.使用:父(parent)子(child)和同胞(sibing)等术语来描述这些节点的层次关系,父节点拥有子节点,同级的子节点被称为同胞或兄弟节点,关系如下:<br>    @在树状中,顶部节点被称为根(root),如<html>节点<br>    @每个节点都可以拥有任意数量的子节点,如<body>的子节点有<img>,<h1>和<p><br>    @同胞节点是拥有父节点的节点,如<img>`</p><h1>和<p>就是兄弟节点,他们的父节点都<body></body></p><h1 id="访问节点"><a href="#访问节点" class="headerlink" title="访问节点"></a>访问节点</h1><p>1.使用DOM Core访问HTML文档的节点<br>主要有两种方式,一种是是由getElement系列方法访问节点,另1.使用getElement系列方法访问指定节点getElementById<br>    1-1.getElementById()返回ID属性查找的第一个对象对象的引用<br>    1-2.getElementByName()返回带有指定名称name查找的对象集合<br>    1-3.getElementByTayName()返回带有指定标签TagName查找的对象的集合<br>2.根据层次关系访问节点<br>通过getElement三种方法都会忽略的结构,因此子HTMl DOM中提供了一些节点属性<br>如下<br>节点属性:<br>    1.parentNodes        返回节点的父节点<br>    2.childNods            返回节点集合,childNods[i]<br>    3.firstChild        返回节点的第一个子节点,最普遍的用法是访问该元素的文本节点<br>    4.lastChild            返回节点的最后一个子节点<br>    5.nextSibing        下一个节点<br>    6.prebiousSiling    上一个节点<br>例:</p><hr><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;节点属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;section id = &quot;news&quot;&gt;        &lt;header&gt;淘宝&lt;a href=&quot;#&quot;&gt;更多&lt;/a&gt;&lt;/header&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试A&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试B&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试C&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试D&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试E&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试F&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是测试G&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/section&gt;    &lt;!--section的子节点是header和ul,header是section的第一个子节点,ul是section节点的最后一个节点--&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h1 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h1><p>节点是DOM层次结构中的任何类型的对象的通用名称,每个节点都拥有着包含着关于节点某些信息性</p><hr><pre><code>nodeName    (节点名称)nodeValue    (节点值)nodeType    (节点类型)</code></pre><hr><p>1.nodeName属性包含某个节点名称,元素节点的nodeName是标签名称,文本节点的nodeName永远是#text文档节点的nodeName永远是#document<br>2.nodeValue节点值,对于节点,nodeValue属性包含文本;对于属性节点,nodeValue属性包含文本包含属性值,nodeValue属性对于文本节点,和元素节点是不可用的<br>3.nodeType属性可返回节点的类型,是一个只读属性,如返回的是元素节点,文本节点的注释节点<br>##节点类型</p><hr><pre><code>节点类型          NodeType值元素Element           1属性attr              2文本txt               4注释comments          5文本document          9</code></pre><hr><p>例:</p><hr><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=&quot;nodelist&quot;&gt;        &lt;li&gt;nodeName&lt;/li&gt;        &lt;li&gt;nodeValue&lt;/li&gt;        &lt;li&gt;nodeType&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        //拿到根节点        var nodes=document.getElementById(&quot;nodelist&quot;);        //拿到根节点下的第一个子节点的类型        var type1=nodes.firstElementChild.nodeType;        //拿到拿到根节点下的第一个子节点的子节点的类型值        var type2=nodes.firstElementChild.firstChild.nodeType;        //  \\   var type2=nodes.firstElementChild.childNodes[0].nodeType;        //拿到拿到根节点下的第一个子节点的子节点的类型名称        var name1=nodes.firstElementChild.firstChild.nodeName;        //拿到拿到根节点下的第一个子节点的子节点的文本值        var str=nodes.firstElementChild.firstChild.nodeName;        alert(&quot;type1:&quot;+type1+&quot;\n&quot;+&quot;type2:&quot;+type2+&quot;\n&quot;+&quot;name1:&quot;+name1+&quot;\n&quot;+&quot;str:&quot;+str);    &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>运行结构:<br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/%E6%95%88%E6%9E%9C1.png"><br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/%E6%95%88%E6%9E%9C2.png"></p><hr><h1 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h1><p>1.操作节点属性</p><hr><pre><code>getAttribute(&quot;属性名&quot;);                //获取属性中的值setAttribute(&quot;属性名&quot;,&quot;属性值&quot;);    //设置属性值</code></pre><hr><p>例:</p><hr><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;        &lt;title&gt;Untitled Document&lt;/title&gt;        &lt;script language=&quot;JavaScript&quot;&gt;            function change() &#123;                var input = document.getElementById(&quot;li1&quot;);                alert(input.getAttribute(&quot;title&quot;));                input.setAttribute(&quot;title&quot;, &quot;杨さん&quot;);                alert(input.getAttribute(&quot;title&quot;));            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul id=&quot;u&quot;&gt;            &lt;li id=&quot;li1&quot; title=&quot;hello&quot;&gt;Yang&lt;/li&gt;            &lt;li&gt;JavaScript&lt;/li&gt;            &lt;li&gt;Haha!&lt;/li&gt;        &lt;/ul&gt;        &lt;input type=&quot;button&quot; value=&quot;Change&quot; onClick=&quot;change();&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>效果图:<br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/yunx1.PNG"><br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/yunx2.PNG"></p><p>2.创建和插入节点</p><hr><pre><code>名称                                       描述createElement(tagName)        创建一个标签名为tagName的新元素节点A.appendChild(B)              把B节点追加到A节点的末尾insertBefore(A,B)             把A节点插入到B节点之前cloneNode(deep)               复制某个指定的节点</code></pre><hr><p>例:</p><hr><pre><code>&lt;!--暂无(没时间写了)--&gt;</code></pre><hr><p>3.删除节点和替换节点</p><hr><pre><code>名称                                                   描述removeChild(node)                                  删除指定的节点replaceChild(newNode,oldNode)属性attr            用其他的节点替换指定的节点</code></pre><hr><p>4.操作节点样式</p><hr><pre><code> style属性：HTML元素 . style . 样式属性 = “值” document . getElementById(&quot;titles&quot;).style.color=&quot;#00000&quot;; document . getElementById(&quot;titles&quot;).style.fonSize=&quot;25px&quot;;</code></pre><hr><p><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/20180331172840211.png"><br>三种设置样式方法:<br>    className属性:<br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/2018033117282091.png"><br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/20180405103113268.png"></p><p>5.获取元素的样式</p><hr><pre><code>    语法一：  HTML 元素 . style . 样式属性；    示例：  alert( document . getElementById（“carList”）. style . display )；    语法一： 只能获取内联样式的属性值， 无法获取内部样式表 或 外部样式表的属性值。    语法二：document.defaultView.getComputedStyle( 元素，null ) . 属性；    示例：var  carList = document.getElementById( &quot;carList&quot; );          alert( documen . defaultView.getComputedStyle（carList，null）. dispaly );    语法二：可以实现获取样式属性值    语法三：HTML元素 . currentStyle . 样式属性；            alert（document . getElementById（“carList”）. currentStyle . display）;    语法三指兼容 IE 浏览器</code></pre><hr><hr><p>#JavaScript获取元素位置<br><img src="/2020/10/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/20180331184910560.png"><br>    1.元素属性应用<br>        document . documentElement . scrollTop；<br>        document . documentElement . scrollLeft；<br>        或者<br>        document . body . scrollTop；<br>        document . body . scrollLeft；<br>        两者的区别在于：针对于不同的浏览器  上述针对 标准浏览器使用    下着针对 Chrome</p></h1></h1></body></html></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="2020/10/28/JavaScript%E5%9F%BA%E7%A1%80/"/>
      <url>2020/10/28/JavaScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>JavaScript是基于对象的语言<br>JavaScript是基于事件驱动的语言<br>JavaScript是运行在浏览器中的脚本语言<br>JavaScript是弱类型的语言。类型使用var定义，而且真正的类型由 其存储的值得类型决定</p><hr><p>#JavaScript特点:<br>    向html页面中添加交互行为（动态特效<br>    脚本语言（数据类型、变量、循环、输入和输出）<br>    解释性的语言</p><hr><p>#JavaScript的组成:<br>    ECMAScript        JavaScript核心<br>    BOM                浏览器对象核心<br>    DOM                文档对象模型</p><hr><p>#JavaScript基本结构:</p><hr><pre><code>&lt;script type = &quot;text/javascript&quot;&gt;    ECMAScript/javascript核心语法(定义变量`循环`判断`输出等)&lt;script&gt;</code></pre><hr><hr><p>#HTML注释:</p><hr><pre><code>&lt;!--注释类容--&gt;</code></pre><hr><p>#JavaScript注释：</p><hr><pre><code>//单行注释/*多行注释*/document.write(&quot;文本内容或HTML标签&quot;)</code></pre><hr><p>#JavaScript执行原理:<br>    当用户使用浏览器打开页面，页面中的html代码和javascript代码被加载<br>    当用户提交合法有效的数据，发送给服务器端则服务器端提供响应，且返回界面（界面中包含html或javascript代码）<br>    当用户提交不合法数据，点击按钮则在客户端的浏览器中直接拦截且不向服务器发送请求<br>    即:<br>        JavaScript是在客户端浏览器中的一道屏障，该屏障主要力保服务器端接受的数据和请求是有效地。提供服务器端的使用效率</p><hr><p>#JavaScript的代码分为两种形式:<br>    1、直接嵌入到html代码中<br>    2、引入外部js文件 </p><hr><p>#JavaScript数据类型:<br>    undefined        变量声明未 赋值则输出为undefined<br>    null            值为null，与undefined值相等<br>    number            整数或小数<br>    boolean            true或false<br>    string            ‘’或””</p><hr><p>#typeof检测变量的返回值:<br>    typeof运算符返回值如下:<br>        undefined        变量被声明后，但未被赋值或未声明<br>            例如：<br>                typeof(x)<br>                var y;<br>                typeof(y)<br>        string            用单引号或双引号来声明的字符串<br>            例如：<br>                typeof(‘a’)<br>                typeof(“b”)<br>        boolean：        true或false<br>            例如：<br>                typeof(true)<br>                typeof(false)<br>        number：        整数或浮点数<br>            例如：<br>                typeof(10)<br>                typeof(1.0)<br>        object：        javascript中的对象、数组和null<br>            例如：<br>                typeof(null)</p><hr><h2 id="弹出对话框"><a href="#弹出对话框" class="headerlink" title="弹出对话框"></a>弹出对话框</h2><pre><code>alert(&quot;消息内容&quot;);</code></pre><hr><h2 id="在浏览器中输出消息内容"><a href="#在浏览器中输出消息内容" class="headerlink" title="在浏览器中输出消息内容"></a>在浏览器中输出消息内容</h2><pre><code>document.write(&quot;消息内容&quot;);</code></pre><hr><h2 id="确认和取消对话框"><a href="#确认和取消对话框" class="headerlink" title="确认和取消对话框"></a>确认和取消对话框</h2><pre><code>confirm()</code></pre><hr><h2 id="输入对话框"><a href="#输入对话框" class="headerlink" title="输入对话框"></a>输入对话框</h2><pre><code>prompt(&quot;消息内容&quot;,&quot;默认值&quot;)</code></pre><hr><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="#控制语句"></a>#控制语句</h2><pre><code>if-elseswitch-casebreak        //一般使用在循环或switch-case中，作用就是跳出结束continue    //一般使用在循环中，作用就是结束本次循环继续下次循环</code></pre><hr><p>#函数<br>    分类:<br>        系统函数:<br>            parseInt(字符串)    将字符串转换成整数<br>            parseFolat(字符串)    将字符串转换成浮点<br>            isNaN()                判断是不是数字,是数字返回false,否则为true<br>        用户自定义函数:<br>            定义:函数即为方法,是为了完成特定功能而编写的代码块<br>            语法:<br>                —-<br>                function 函数名(参数列表){<br>                    return 值;<br>                }<br>                —-<br>            注意:<br>                函数需要先声明后方可调用<br>                函数没有返回类型,返回类型由函数体内的return后的值类型决定</p><hr><h2 id="取文本框值的语法"><a href="#取文本框值的语法" class="headerlink" title="#取文本框值的语法:"></a>#取文本框值的语法:</h2><pre><code>var info= document.all.name属性名.value;            //根据Name名取var info = document.getElementById(&quot;ID名&quot;).innerHTML//根据ID值取</code></pre><hr><p>##参考文献<br><a href="http://www.xiaoyangmingbaile.cn/">www.xiaoyangmingbaile.cn</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL使用存储过程注册用户</title>
      <link href="2020/10/20/MySQL%E4%BD%BF%E7%94%A8%E5%82%A8%E5%AD%98%E8%BF%87%E7%A8%8B%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7/"/>
      <url>2020/10/20/MySQL%E4%BD%BF%E7%94%A8%E5%82%A8%E5%AD%98%E8%BF%87%E7%A8%8B%E6%B3%A8%E5%86%8C%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>新来的老师给的第一个作业：用存储过程写一个注册<br>之前也没学过，百度了半天终于弄出来了</p><hr><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="#代码如下:"></a>#代码如下:</h2><pre><code>DELIMITER $$USE `mysql`$$DROP PROCEDURE IF EXISTS `cr_user`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `cr_user`(IN _name VARCHAR(20), IN _pwd VARCHAR(18))BEGINDECLARE p_sqlt VARCHAR(1000);SET p_sqlt = CONCAT(&#39;create user &#39;, _name, &#39; identified by \&#39;&#39;, _pwd, &#39;\&#39; &#39;);SET @cr_sentence = p_sqlt;PREPARE  ec1 FROM @cr_sentence;EXECUTE ec1;END$$DELIMITER ;</code></pre><hr><h2 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="#执行存储过程"></a>#执行存储过程</h2><pre><code>CALL cr_user(&#39;用户名&#39;,&#39;密码&#39;)</code></pre><hr><p>##参考文献<br><a href="http://www.baidu.com/">www.baidu.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="2020/10/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>2020/10/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>##第一章 搭建博客</p><p>安装Nodejs<br>node -v #查看node版本<br>npm -v #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a> #安装淘宝的cnpm管理器后面下载东西会快一些<br>cnpm -v     #查看cnpm版本<br>cnpm install -g hexo-cli #安装hexo框架<br>hexo -v    #查询hexo版本<br>创建blog目录<br>D:<br>cd D:\Software\blog    #进入blog目录<br>hexo init    #生成博客  初始化博客  (这个过程可能会比较慢)<br>hexo s #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇博客文章” #创建新的博客文章<br>#返回blog目录<br>hexo clean #清理一下<br>hexo g    #生成<br>#Github创建一个新的仓库The-Loners.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p><hr><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="#配置_config.yml "></a>#配置_config.yml </h2><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:      type: git     repo: https://github.com/YourGithubName/YourGithubName.github.io.git      branch: master</code></pre><hr><p>hexo d    #部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</p><p> git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库</p><p>#查看博客<br><a href="https://the-loners.github.io/">https://the-loners.github.io/</a></p><hr><p>##第二章</p><p>内容</p><hr><p>##参考文献</p><p><a href="http://www.baidu.com/">www.baidu.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建踩坑记录</title>
      <link href="2020/10/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>2020/10/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="xxx-blog找不到hexo模块"><a href="#xxx-blog找不到hexo模块" class="headerlink" title="#xxx/blog找不到hexo模块"></a>#xxx/blog找不到hexo模块</h2><p>我的是因为安装了某个插件导致报错(中文链接转拼音 hexo-permalink-pinyin)<br>我也不知道为什么会报错，但是的确是卸载之后hexo指令正常了</p><hr><h2 id="卸载插件指令"><a href="#卸载插件指令" class="headerlink" title="卸载插件指令:"></a>卸载插件指令:</h2><p>npm list<br>npm uninstall 需要卸载的插件名字</p><hr><p>##参考文献<br><a href="http://www.baidu.com/">www.baidu.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/02/hello-world/"/>
      <url>2020/10/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
